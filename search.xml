<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS中的转码问题]]></title>
      <url>%2F2018%2F06%2F26%2FiOS%E4%B8%AD%E7%9A%84%E8%BD%AC%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[由一个汉字二次编码，引起的知识补充汉字二次编码： 文 -&gt; （一次UFT-8编码）%E6%96%87 -&gt; （二次UFT-8编码）%25E6%2596%2587 1 GB2312、GBK、GB18030与UTF-8的区别 GB2312 国家标准，支持中文字符 GBK GB2312的拓展 不论中、英文字符均使用双字节来表示，中文将其最高位设定成1。 通用性比UTF8差，不过UTF8占用的数据库比GBD大 GB18030 GBK的拓展 采用了2\4位混和的办法，兼容GB2312和GBK2字节编码的文件 UTF-8 全称：Unicode Transformation Format-8bit，允许含BOM，但通常不含BOM 英文使用8位（即一个字节），中文使用24位（三个字节） 包含全世界所有国家需要用到的字符，是国际编码，通用性强 2 相互转换 通过Unicode编码相互转换 3 ASCll编码和Unicode编码的区别 ASCII编码 1个字节 ASCII 码一共定义了 128 个字符 大写的字母 A 是 65（这是十进制数，对应二进制是0100 0001） 这 128 个字符只使用了 8 位二进制数中的后面 7 位，最前面的一位统一规定为 0 Unicode编码 通常是2个字节，可以更多 UTF-8编码 把Unicode字符根据不同的数字大小编码成1-4个字节 编码规则如下 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点，因此与 ASCII 码完全相同 对于 N 个字节的字符（N &gt; 1）， 第一个字节的前 N 位都设为 1，第 N + 1 位设为0 剩余的 N - 1 个字节的前两位都设位 10 剩下的二进制位则使用这个字符的 Unicode 码点来填充 UNICODE 十六进制码点范围 UTF-8 二进制 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 编码例子 “汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx 接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上 这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89 解码规则如下 如果一个字节的第一位是 0 ，则说明这个字节对应一个字符； 如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节 4 iOS中URL编码和解码4.1 为什么需要URL编码 URL中有些字符会引起歧义 例如：URL参数字符串中使用键值对(key=value)的方式来传参，键值对之间以&amp;符号分隔,因此键值中的&amp;符号必须进行编码 URL的编码格式采用的是ASCII码，而不是Unicode URL中不能包含任何非ASCII字符，例如中文 4.1 URL编码、解码 URL编码的原则 就是使用安全的字符(没有特殊用途或者特殊意义的可打印字符)去表示那些不安全的字符 中文、空格字符编码 stringByAddingPercentEscapesUsingEncoding(只对 `#%^{}[]|\”&lt;&gt; 加空格共14个字符编码，不包括”&amp;?”等符号) stringByAddingPercentEncodingWithAllowedCharacters（ ios9） 123456789NSString * resourcePath = @&quot;https://www.baidu.com/文件夹&quot;// 编码(iOS9.0以下使用）NSString *str3 =[resourcePath stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];(iOS9.0以及以上使用）NSString *str3 =[resourcePath stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSString *str3 =[resourcePath stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet characterSetWithCharactersInString:@&quot;`#%^&#123;&#125;\&quot;[]|\\&lt;&gt;&quot;].invertedSet]; 中文、空格字符解码 stringByReplacingPercentEscapesUsingEncoding stringByRemovingPercentEncoding （ios9） 123456NSString * resourcePath = @&quot;https://www.baidu.com/文件夹&quot;; // 解码(iOS9.0以下使用）NSString *str2 = [resourcePath stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];(iOS9.0以及以上使用）:NSString *str2 = [resourcePath stringByRemovingPercentEncoding]; 4.2 NSCharacterSet 中的字符 URLFragmentAllowedCharacterSet “#%&lt;&gt;[]^`{|} URLHostAllowedCharacterSet “#%/&lt;&gt;?@\^`{|} URLPasswordAllowedCharacterSet “#%/:&lt;&gt;?@[]^`{|} URLPathAllowedCharacterSet “#%;&lt;&gt;?[]^`{|} URLQueryAllowedCharacterSet “#%&lt;&gt;[]^`{|} URLUserAllowedCharacterSet “#%/:&lt;&gt;?@[]^` 5 原码、反码、补码 原码：一个整数，按照绝对值大小转换成的二进制数 最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小 比如5的原码：00000000 00000000 00000000 00000101 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码 正数的反码与其原码相同 负数的反码是对其原码逐位取反，但符号位除外 取反操作指：原为1，得0；原为0，得1。（1变0; 0变1） 补码：反码加1称为补码 正数的补码和原码相同 负数以其正值的补码形式表达 比如5的补码（也就是-5的表达方式）：11111111 11111111 11111111 11111011 无符号位取值范围 0~255 （因为计算机是从0开始计算的而不是1） 0～2^8 - 1 (256 -1) 有符号位取值范围 -128 ～ +127 -2^7（-128） ~ 2^7-1 （128-1） 6 URL中的特殊字符 URL中只允许包含英文字母(a-zA-Z)、数字(0-9)、4个特殊字符(- _ . ~)以及所有保留字符，如果要在URL中传递这些特殊符号，那么就要使用他们的编码了 编码的格式为：百分号（%）加字符的ASCII码（16进制）码值 符号 特殊含义 十六进制值 部分保留字符 &lt; %3C &gt; %3E “ 普通文本中起到分隔Url的作用 %22 # 通常用于表示书签或者锚点 %23 % 指定特殊字符 %25 { %7B } %7D \ %5C ^ 加字号 %5E ～ 波浪 %7E [ %5B ] %5D ` 反单引号 %60 空格 %20 * %2A ‘ %27 ( %28 ) %29 + 表示空格（在URL中不能使用空格） %2B $ 表示空格（在URL中不能使用空格） %24 , 表示空格（在URL中不能使用空格） %2C 保留字符 ; %3B / 分隔目录和子目录 %2F ? 分隔实际的 URL 和参数 %3F : %3A @ %40 = %3D &amp; URL中指定的参数间的分隔符 %26 7 URL的格式 URI（Uniform Resource Identifier）：统一资源标识符 标识/定义资源 URL（Uniform Resource Location）：统一资源定位符 描述如何访问到该资源 12345678protocol :// hostname[:port] / path / [;parameters][?query]#fragmentfoo://example.com:8042/over/there?name=ferret#nose \_/ \______________/ \________/\_________/ \__/ | | | | | scheme authority path query fragment protocol（协议） 指定使用的传输协议，最常用的是HTTP协议 hostname（主机名） 存放资源的服务器的域名系统(DNS) 主机名或 IP 地址 port（端口号） 各种传输协议都有默认的端口号，如http的默认端口为80 path（路径） 由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 parameters（参数） 指定特殊参数的可选项 query(查询) 可选，用于给动态网页传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开 fragment（信息片断） 字符串，用来标识 URI 所标识资源里的某个资源 8 处理字符串的方法 ：NSCharacterSet\NSMutableCharacterSet 常用API学习 1234567891011121314151617181920//NSCharacterSet/** 001 根据一个给定的字符串获取一个NSCharacterSet对象 */+ (NSCharacterSet *)characterSetWithCharactersInString:(NSString *)aString;/** 002 相反字符串限制 【具体见接下的例子】 */@property (readonly, copy) NSCharacterSet *invertedSet;/** 003 常用快捷方法集合 （常用的，已满足大多数需求） */+ controlCharacterSet+ whitespaceCharacterSet //空格+ whitespaceAndNewlineCharacterSet //空格和换行符+ decimalDigitCharacterSet //0-9的数字+ letterCharacterSet //所有字母+ lowercaseLetterCharacterSet //小写字母+ uppercaseLetterCharacterSet //大写字母+ alphanumericCharacterSet //所有数字和字母（大小写不分）+ punctuationCharacterSet //标点符号+ newlineCharacterSet //换行//NSMutableCharacterSet/** 001 功能同 invertedSet 方法一样，注意这个没有返回值 */- (void)invert; 应用1：textFielf只能输入数字 12345678- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123;NSCharacterSet *charSet = [[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;] invertedSet];NSString *filteredStr = [[string componentsSeparatedByCharactersInSet:charSet] componentsJoinedByString:@&quot;&quot;];if ([string isEqualToString:filteredStr]) &#123;return YES;&#125;return NO;&#125; 9 解析URL的方法 ： NSURLComponents12345678910111213141516171819202122232425262728293031初始化方法如下：- (instancetype)init;- (nullable instancetype)initWithURL:(NSURL *)url resolvingAgainstBaseURL:(BOOL)resolve;+ (nullable instancetype)componentsWithURL:(NSURL *)url resolvingAgainstBaseURL:(BOOL)resolve;- (nullable instancetype)initWithString:(NSString *)URLString;+ (nullable instancetype)componentsWithString:(NSString *)URLString;//常用的属性如下：@property (nullable, readonly, copy) NSURL *URL;@property (nullable, readonly, copy) NSString *string NS_AVAILABLE(10_10, 8_0);@property (nullable, copy) NSString *scheme; // Attempting to set the scheme with an invalid scheme string will cause an exception.@property (nullable, copy) NSString *user;@property (nullable, copy) NSString *password;@property (nullable, copy) NSString *host;@property (nullable, copy) NSNumber *port; // Attempting to set a negative port number will cause an exception.@property (nullable, copy) NSString *path;@property (nullable, copy) NSString *query;@property (nullable, copy) NSString *fragment;@property (nullable, copy) NSString *percentEncodedUser;@property (nullable, copy) NSString *percentEncodedPassword;@property (nullable, copy) NSString *percentEncodedHost;@property (nullable, copy) NSString *percentEncodedPath;@property (nullable, copy) NSString *percentEncodedQuery;@property (nullable, copy) NSString *percentEncodedFragment;@property (nullable, copy) NSArray&lt;NSURLQueryItem *&gt; *queryItems NS_AVAILABLE(10_10, 8_0); 应用1： iOS 解析url中的key和value 12345678910111213NSString* wxNASAURLPath = @&quot;http://www.ruyizi.com/url?a=1&amp;b=2&amp;c=3&quot;;NSURLComponents* wxNASAURLComponents = [NSURLComponents componentsWithString:wxNASAURLPath];NSMutableDictionary* queryItemDict = [NSMutableDictionary dictionary];NSArray* queryItems = wxNASAURLComponents.queryItems;for (NSURLQueryItem* item in queryItems) &#123;[queryItemDict setObject:item.value forKey:item.name];&#125; 参考1 彻底弄懂 Unicode 编码2 NSURL/NSURLComponents3 percent-encode 百分号编码4 URI’s fragment5 学会NSCharacterSet，再也不怕各种字符串处理6 NSURLComponents的使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多工程工作]]></title>
      <url>%2F2018%2F05%2F05%2F%E5%A4%9A%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[1 workspace 管理多个project1.1 应用场景项目有可能要使用其他的项目文件，或者引入其他的静态库文件，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，可以减少来回切换项目 1.2 步骤 1 File &gt; New Workspace 新建一个空的workspace 2 File &gt; New Project 建一个工程myProduct和一个framework工程myStaticFramework 3 File &gt; Add file to workspace 将myProduct和myStaticFramework工程添加进去 4 Build Setting &gt; User Head Search Paths （或者Head Search Paths） 添加myStaticFramework路径 5 Build Phases &gt; Link Binary With Libraries 添加myStaticFramework工程编译出来的myStaticFramework.framework 6 Copy Files （1）Destination改为Framework （2）添加myStaticFramework工程编译出来的myStaticFramework.framework 2 一个Project多target工作2.1 应用场景在实际开发过程中难免会遇到同一个项目要发多个版本来服务于业务的需求,而两个版本仅有微小的不同. 比如我们要发的版本有: 1.数据版DataTrack-Debug(给数据组,用于埋点统计) 2.测试版Test-Debug(给测试组,用于上线前测试) 3.企业版Enterprise-Debug(给第三方测试,用于更专业更客观的测试) 4.线上版Online(给测试组,用于测试后端上线后对前端的影响) 2.2 步骤 复制target 选择需要复制的target–&gt;右键点击–&gt;选择Duplicate 新target在项目中会生成 XXX copy target XXX copy Scheme XXX copy-Info.plist 改名字 修改Target名字，双击修改 修改新的Plist文件 如果需要挪动plist，则挪动完了以后需要关联一下 target–&gt;General–&gt;Choose Info.plist File 修改Scheme名称 Target–&gt;Edit Scheme–&gt;Manage Schemes–&gt;修改名称 3 静态库与动态库库(Library)是一段编译好的二进制代码，加上头文件就可以供别人使用。编译的时候只需要link一下，link（链接阶段）的不同的形式（静态或动态）决定库是静态库还是动态库 编译过程： 1源文件 -&gt; 预编译 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 可执行文件 一般会有两种情况要用到库： 某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件 公司中常用且变动很少的模块可以编译成库，这样做的好处一是可以节省编译时间，二来对于代码的管理也非常方便 3.1 静态库（.a、.framework） 静态库在链接(link)阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中，对应的链接方式称为静态链接。一个静态库可以简单看成是一组目标文件（.o/.obj文件）的归档集合 静态库的特点： 静态库嵌入App 在App项目编译的时候会被编译到目标程序中，所以得到的App二进制文件会变大 浪费空间和资源的弊端 不同的应用程序如果调用相同的库，那么在内存里会有多份该共享库的实例 静态库更新，程序需要重新编译 静态库依赖的其他类库，需要手动导入 减少耦合 不可以包含其他静态库 每一个静态库都是独立的，不会重复引用 StaticLibrary需要设置头文件搜索路径，Framework不需要 共享运行环境（一个应用程序中） 假如其运行环境中包换库中同一个类，会发生代码冲突，必须剥离其中一方的此类，然后共享此类 framework和.a两种静态库的区别 .a是一个纯二进制文件 .framework中除了有二进制文件之外还有资源文件 .a文件不能直接使用，至少要有.h文件配合 .framework文件可以直接使用。 .a + .h + sourceFile = .framework。 .a只是静态库 framework既可以是静态库也可以是动态库 3.2 动态库（.framework、.dylib、.tbd） 动态库在链接(link)阶段，不会被链接到目标代码中，而是在程序运行是才被载入 动态库（也称共享库）的特点： 程序运行时才被载入 避免浪费空间和资源的弊端 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例 增量更新 动态库更新，程序不需要重新编译 动态库可以包含静态库，也能自动link所需要的依赖库 与运行环境隔离 运行环境中包换库中同一个类，不会发生冲突，同名的两个类会在各自的环境中独立运行，互不干扰，哪怕是单例类 注意： 1 苹果在iOS 8之前并不支持自己开发的framework. 2 自己开发的framework无论是动态还是静态的，都要复制到目标程序，苹果又把这种Framework叫做Embedded Framework 3 Xcode中需要导入我们自己制作的动态库时，需要在Xcode中的Build phase-&gt;Copy Files选项添加,其中destination选择“Frameworks”，不然会报错：image not found。 3.3 判断库是动态库还是静态库,用file命令1234567891011$ cd myframework.Frameworks$ ls -l myframework$ file myframework#静态库，显示archive&gt; myframework.Frameworks: Mach-O universal binary with 2 architectures: [arm_v7:current ar archive] [arm64]&gt; myframework.Frameworks (for architecture armv7): current ar archive #动态库，dynamically&gt; myframework: Mach-O universal binary with 2 architectures: [arm_v7] [arm64:Mach-O 64-bit dynamically linked shared library arm64]&gt; myframework (for architecture armv7): Mach-O dynamically linked shared library arm_v7 3.4 合并两个静态库1lipo -create 模拟器静态库（动态库） 真机静态库（动态库） -output 新静态库的名称（动态库） 注意： 动态库不是合成.framework，是合成.framework里面的一个黑色文件（二进制文件），生成的也是这个黑色文件，只需将合成的黑色文件替换就好了 如果制作的是动态库的话，一定要embeded binaries中将库导入一下（target —&gt; General —&gt; Embedded Binaries下添加你的动态链接库） 或者你也可以将动态库当做一个资源文件使用在Build Phases-&gt;Copy Bundle Resources中添加，然后就可以用bundle的方式使用动态库了 如果库中包含系统的分类，一定要在target linker flag 里面配置-ObjC以及-all_load 1234567891011NSString *documentsPath = [NSString stringWithFormat:@&quot;%@/Documents/FWPaySdk.framework/FWPaySdk&quot;,NSHomeDirectory()]; NSError *err = nil; NSBundle *bundle = [NSBundle bundleWithPath:documentsPath]; if ([bundle loadAndReturnError:&amp;err]) &#123; NSLog(@&quot;bundle load framework success.&quot;); &#125; else &#123; NSLog(@&quot;bundle load framework err:%@&quot;,err); &#125; Class worder = NSClassFromString(@&quot;FWorder&quot;); FWorder * order = (FWorder *)[[worder alloc] init]; 4 Framework、.a、.dylib/.tbd4.1 .Framework（框架） Headers Framework需要暴露的头文件 binary文件 整个Framework的核心，所有代码都被编译成了这样一坨二进制文件， 添加的依赖库不会被编译进来，用的时候需要重新link其他依赖库。 .bundle 资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源 图片放进bundle之后不可以用[UIImage ImageWithName:]读取图片。要先找到bundle包再拿图片 12345#define BUNDLE_NAME @&quot;Resources.bundle&quot;#define BUNDLE [NSBundle bundleWithPath: [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent: BUNDLE_NAME]]#define LOADIMAGE(name) [UIImage imageWithContentsOfFile:[[BUNDLE resourcePath] stringByAppendingPathComponent:name]] ​ Info.plist和Modules 记录Framework的版本等相关信息，一般都会删掉 注意： 1 Framework是动态库还是静态库，取决于编译成的Mach-O（就是那个二进制文件） 2 Buiding Setings -&gt; Mach-O Type: 默认选择的是Dynamic Library(动态库)，选择Static Library是静态库 4.2 .a 这类静态库与Framework基本类似，在打包成.a文件的同时，还需要提供头文件，而Framework编译完成暴露的头文件都已经放好了 4.3 .dylib/.tbd 基本上都是系统提供的动态库 5 如何选择使用Framework还是StaticLibrary 假如不想在同一个App中包含多份三方库(减小包大小)，可以使用StaticLibrary，库本身和App共享第三方库。但是产出物的结构可能会比较乱。 假如不想考虑和App的代码冲突问题，库本身独立使用需要的库，想提供比较好的库结构，可以使用Framework。但是假如库本身和App都使用了同一个三方库，会存在两份三方库，会增加包大小。 6 iOS自动化版本号和编译号agvtool 是一个增加版本号的命令行工具 版本号（Version） 给用户看的，用于标明当前的发行版本 存储在 Info.plist 文件的 CFBundleShortVersionString (Bundle versions string, short)中 编译号（Build） 内部使用的，用于标明未发行或者已内部发行的应用程序 存储在 Info.plist 文件的 CFBundleVersion (Bundle version) 中 注意：如果应用程序包含了多个目标（target），agvtool 工具将会把所有目标都设置为同一个版本号和编译号。 6.1 启用 agvtool 设置 Current Project Version 为选定的值 Xcode 工程文件project.pbxproj包含了 CURRENT_PROJECT_VERSION (Current Project Version)编译设定，这个编译设定指定了当前工程的版本。agvtool 会搜索此编译选项。如果这个值存在就运行，否则不运行，这个值用来更新编译号 设置 Versioning System 为 Apple Generic 默认情况下苹果不使用任何版本系统，设置为 Apple Generic 确保 Xcode 包含全部的 agvtool 生成的版本信息 6.2 设置版本和编译号 进入到包含 .xcodeproj 工程文件的目录 更新版本号 123456/*注意： 如果存在多个Xcode需要选择一个，否则报错。 sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer*/ agvtool new-marketing-version 2.1 更新编译号 1234//自动更新编译号 agvtool next-version -all //更新编译号 agvtool new-version -all 2.1 查看版本号 1agvtool what-marketing-version 查看当前编译号 1agvtool what-version 7 其他：1 User Head Search Paths 和Head Search Paths的区别共同点 用来存放 Project 中头文件的搜索根源，没有被add到项目里的头文件 区别 Xcode设置了Header Search Paths，则一定会去搜索的。 UserHeader Search Paths只有在Always Search User Paths（是否搜索用户路径）为Yes时才会被搜索 &lt;&gt; 是从系统目录空间 （对应 Header Search Paths）中搜索文件，只在Header Search Paths 中搜索 “” 是从用户目录空间（对应 User Header Search Paths）中搜索文件，如果没有则去Header Search Paths 搜索 2 iOS Code Sign On Copyxcode中embed的framework，都是需要签名的。如果在生成framework时，签过名了，就不用在选上 code sign on copy选项了。如果没有签过名，必须选上，不然无法在真机上运行！ 3.常见模拟器&amp;真机所使用的CPU架构 模拟器使用的CPU架构 iPhone3gs~iPhone5 : i386 iPhone5s~iPhone7plus : x86_64 真机设备CPU架构 iPhone3gs~iPhone4s : armv7 iPhone5~iPhone5c : armv7s(只要支持armv7即可) iPhone5s~iPhone7plus : arm64 8 参考：1 WWDC 2014 Videos 2 使用CocoaPods开发并打包静态库 3 iOS 最新framework和.a静态库制作及使用全解(含工程套工程，多工程联调) 4 iOS 静态库，动态库与 Framework) 5 App Extension Programming Guide 6 iOS静态库SDK制作（包含第三方静态库） 7 Automating Version and Build Numbers Using agvtool mechanism 机制 conditionally 有条件的 Explore 探索 implement实施 Deploying 部署 Adopting 采用 technologies 技术 facilitate 促进 corresponding 对应的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[点击 Run 之后发生了什么]]></title>
      <url>%2F2018%2F05%2F05%2FXcode%20Run%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[原文：点击 Run 之后发生了什么？ 简单来说，点击 Run 之后 App 进行编译、汇编、链接、代码签名以及启动执行等操作 一 编译 编译主要依靠编译器来完成一系列的操作 主要操作有 预处理 词法分析 语法分析 语义分析 生成中间代码 生成目标代码 优化目标代码 OS X 现在使用的编译器是 LLVM （Low Level Virtual Machine），在最初使用的是 GCC作为官方的编译器，但是由于下面的众多限制，apple 使用了自己的一套编译器 GCC 原名为GNU C语言编译器，它原本只能处理 C语言，后来扩展了Objective-C、Java等语言，但是对于Objective-C的处理还是存在众多不便 GCC 效率低下、性能不强 苹果开发自己的编译器，有利于开展自己的工具链，比如后期做 Swift、lldb 等 llvm 的基本架构 1 编译器 编译器前端（clang） 负责产生机器无关的中间代码 编译器后端 负责对中间代码进行优化并转化为目标机器代码 中间代码（IR：intermediate representation）也称为中间表示 通过中间代码为不同的语言针对诸多架构生成代码 2 预处理 处理源文件中以 #开头的预编译命令，比如#include等 3 词法分析将输入分解为一个个独立的词法符号，也叫单词符号（token） 注释、宏、空格、换行等都不是单词 例子： 1234567// 1 find a zerofloat matchZero(char *s) &#123;&#125;//2 返回下列单词流//大概了解即可，觉得背这些词法符号定义对目前 iOS 开发用处不大FLOAT、ID(MATCHZERO)、LPAREN、CHAR、ID(S) 、RPAREN 4 语法分析 将符号化的字符串，转化抽象为能被计算机存储的树形结构（即抽象语法树（AST）） 验证语法的正确性 例如：忘记带分号 只能完成语法层面的分析，无法判别整个语句的真正意义 比如类型不匹配就无法检查5 语义分析 类型检查、以及符号表管理 6 生成中间代码 编译器前端 负责产生机器无关的中间代码 7 目标代码的生成与优化编译器后端包括 代码生成器 代码生成器将中间代码转换为目标代码 代码优化器 代码优化器主要是进行一些优化，比如删除多余指令，选择合适寻址方式等 二 汇编 目标代码经过汇编器处理，变成机器上可以执行的指令。生成对应的.o文件 三 链接 链接器（这里指的是静态链接器）将多个目标文件合并为一个可执行文件 在 OS X 和 iOS中的可执行文件是 Mach-O 链接又分为静态链接和动态链接 静态链接 在编译链接期间，把目标文件和静态库一起链接形成可执行文件 静态库如果多个程序都用到了一个库，那么每个程序都要将其链接到可执行文件中，非常冗余 不方便升级，必须重新编译 动态链接 在运行时，把目标文件和动态库一起链接形成可执行文件 多个程序可以共享同一段代码，不需要在磁盘上存多份拷贝 增加启动时间，影响性能 因为动态链接发生在启动或运行时 方便升级 整个过程如下图 四 代码签名 应用构建（build）完成之后会自动调用命令行工具codesign 进行签名，形成一个可以在系统上跑起来的可执行程序 程序一旦签名，就没有办法更改其中的任何东西，包括资源文件，可执行文件等，iOS系统会检查这个签名 我们每次build之后，都会发现工程目录下多了一个.app文件 在 .app目录中，包含一个叫_CodeSignature的子目录 ，它是一个 plist文件 包含了程序的代码签名 五 启动 其实在启动过程中，dyld（动态链接器） 起了很重要的作用，进行动态链接，进行符号和地址的一个绑定 dyld 主要在启动过程中主要做了以下事情： 加载所依赖的dylibs Fix-ups：Rebase修正地址偏移，因为 OS X和 iOS 搞了一个叫 ASLR的东西来做地址偏移（随机化）来避免收到攻击 Fix-ups：Binding确定 Non-Lazy Pointer地址，进行符号地址绑定。 ObjC runtime初始化：加载所有类 Initializers：执行load 方法和attribute((constructor))修饰的函数 对于如何减少启动时间，今年的 WWDC 也有详细的阐述，可以在参考链接中找到相关的资料。 总结 编译 - 汇编 - 静态链接 - 签名 - 启动（动态链接等操作）- 跑起来了 参考链接 虎书 程序员的自我修养 MDCC 2016 - 孙源（Sunnyxx）- clang 概述 iDev 2016 - 孙源（Sunnyxx）- 把玩链接器 优化 App 的启动时间 WWDC 2016 Session 406 名词解释 SPARC 全称为“可扩充处理器架构”（Scalable Processor ARChitecture），是RISC微处理器架构之一 MIPS(Million Instructions Per Second)： 单字长定点指令平均执行速度 Million Instructions Per Second的缩写，每秒处理的百万级的机器语言指令数。这是衡量CPU速度的一个指标 Pentium Pentium（奔腾）是英特尔第五代x86架构的微处理器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android studio mac版本快捷键]]></title>
      <url>%2F2018%2F03%2F21%2FAndroid-studio-mac%E7%89%88%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[1 Mac下快捷键的符号所对应的按键⌥—&gt; option|alt ⇧—&gt;shift ⌃—&gt;control ⌘—&gt;command ⎋—&gt;esc 注: 与F6/F7/F12等F功能键开头的组合的快捷键需要按住fn开启功能键如：快捷键⌘F12的按键组合为：fn + command + F12 2 Android Studio 常用快捷键 for mac1 查找／查看相关⌘O: 全局查找class类名&lt;使用率非常高&gt; ⌘F: 在当前编辑文件中查找&lt;使用率非常高&gt; ｜ 对应window中的Ctrl + F ⌘F12：当前编辑的文件中结构快速导航 | 对应window中的 Ctrl + F12 ⌘E: 打开最近访问的文件列表 | 对应window中的Ctrl + E ⌥⌘O: 输入类名／方法名／字段名来查找任何匹配的类／方法／字段&lt;使用率非常高&gt; ⇧⌘O: 全局项目查找文件（类／资源文件／布局文件都通过该快捷键查找）&lt;使用率非常高&gt; ⌃H: 查看当前编辑class类的hierarchy结构 | 对应window中的Ctrl + H ⌥F7: 列出全局项目中该类／方法 被引用／调用的情况&lt;使用率非常高&gt;[比⌥⌘F7显示效果好] | 对应window中的Alt + F7 ⌥⌘F7: 列出全局项目中该类／方法 被引用／调用的情况 | 对应window中的Ctrl + Alt + F7 ⌃⌥H: 方法被调用结构［method’s Call Hierarchy］| 对应window中的ctrl + alt + h ⌘P: 列出函数方法一系列的有效参数，如果光标是一个方法调用的括号之间 | 对应window中的Ctrl + P ⇧⌘F7: 快速，高亮显示变量在当前文件中的引用情况,使用⌘G和⇧⌘G快捷键 可以前往跳到下一个/上一个高亮的变量，按⎋移除高亮显示 | 对应window中的Ctrl + Shift + F7 F1: 查看类／方法的注释文档 2 控制操作相关⌘/: 注释与取消注释，注释效果 //... | 对应window中的Ctrl + / ⌥⌘/: 注释与取消注释，注释效果 /*...*/ | 对应window中的Ctrl+Shift+/ ⇧⌥up/down: 移动行上下移动 | 对应window中的alt + shift + up/down ⌘delete: 删除行 ｜ 对应window中的ctrl + y ⌘d: 复制行 ｜ 对应window中的 ctrl + d ⌘J: 快速生成模版代码块，如if,while,return等&lt;使用频率非常高，高效率编写代码&gt; | 对应window中的Ctrl + J ⌘N: 快速生成getter／setter方法，构造方法，toString()方法等 &lt;使用率非常高&gt; | 对应window中的Alt + Insert ⌥⌘T: Surround with快速调出if,for,try...catch,while等环绕代码 ｜ 对应window中的ctrl + alt + t ⌃O: 引入重写父类的方法［Override Methods］&lt;使用率非常高&gt; ⌃I: 引入实现接口或抽象类方法［Implement Methods］&lt;使用率非常高&gt; ⌃Space: 当申明一个变量时，根据变量类型提示给出建议的变量名称，等还有其他很多智能提示作用&lt;使用率非常高&gt; ⌥⌘L: 代码格式化 &lt;使用率非常高&gt; | 对应window中的Ctrl+Alt+L 3 代码重构相关⇧F6:代码重构时，类名／方法名／变量名 重命名操作 | 对应window中的Shift + F6 ⌘R: 代码重构时，可以用来批量重命名变量 ⌥⌘M: 方法重构，方法抽离 ｜对应window中的Ctrl+Alt+M ⌥⌘P: 参数重构，将方法内变量抽离成方法参数 ｜对应window中的Ctrl+Alt+P ⌥⌘V: 变量抽离，&lt;使用率非常高&gt; | 对应window中的Ctrl+Alt+V 1new StringBuffer() 使用快捷键后效果如下： 1StringBuffer stringBuffer = new StringBuffer(); ⌥⌘F: 字段抽离，将方法内的变量抽离成类字段申明,简单说就是把变量的申明从方法内重构抽离到方法外 ｜ 对应window中的Ctrl+Alt+F 4 工程设置Preferences下Editor —&gt;General-&gt; Code Completion —&gt;Case sensitive completion 调成 none ，使大小写不敏感Editor —&gt;General-&gt; Other -&gt;Show quick doc on mouse move 打勾，鼠标移动到方法上显示apiEditor —&gt;General-&gt; Auto Import —&gt;Optimize imports on fly 打勾，把不用的声明移除掉，相当于Ctrl + Alt + O 5 其他快捷键⇧⌘A: 你可以调用任何菜单或动作的名称在Android studio中 ｜ 对应window中的ctrl + shift + a 下面我就是个人觉得有用的快捷(虽然有些可能也没用到过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445CTRL + R Build and runOPTION + CMD + O 查找工程内的文件或方法或字段CMD + 0 查找工程内的类文件CMD + P Show parameters for selected methodOPTION + CMD + L Reformat codeCMD + N Generate methodCMD + R 相当于搜索替换CMD + , 打开PreferencesCMD + ; 打开Project StructureCMD + X 删除行CMD + D 复制行CTRL + J 显示该方法或类的apiCMD + [ 返回上一次编辑位置CMD + ] 前进到上一次编辑位置CTRL + P 鼠标移动到上一行CTRL + N 鼠标移动到下一行ALT + ENTER 导入包，自动修正（未验证）SHIFT + CMD + [ previous tabSHIFT + CMD + ] next tab ALT + 向上键 选择当前光标处所在单词或行CTRL + ALT + H 查找调用的位置ALT + SHIFT + UP/DOWN 上下移动代码CTRL + O 快捷覆写方法ALT + CTRL + O 清除无效引用ALT + ENTER 提示错误解决方案(在抽取局部变量时，调出对话框后选第二个)CMD + SHIFT + F 相当于 Eclipse 的 Ctrl + hCTRL + T 调出Refactor选项框，可以抽取方法、成员变量等CMD + ALT + V 相当于Eclipse的Ctrl + 2 ,L 自动生成变量CMD + ALT + F 抽取成成员变量CMD + SPACE 相当于 Eclipse 的ALT + /，不过与系统的切换输入法冲突，修改快捷键搜索 BasicALT + / 自动补全最后一个方法名(原)keymap —&gt;Reformat Code 添加ALT + FAndroid_Studio 导入项目1、修改buid.gradle文件的classpath 为自带最新：eg. dependencies &#123; classpath 'com.android.tools.build:gradle:1.0.0-rc1’ &#125;2、修改gradle/wrapper/gradle-wrapper.properties文件的distributionUrl(看需要)：eg. distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zipCTRL + CMD + F 全屏切换，期间导致过一次工具栏消失]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信Mac客户端如何做到消息防撤回和多开]]></title>
      <url>%2F2018%2F03%2F20%2F%E5%BE%AE%E4%BF%A1Mac%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%B6%88%E6%81%AF%E9%98%B2%E6%92%A4%E5%9B%9E%E5%92%8C%E5%A4%9A%E5%BC%80%2F</url>
      <content type="text"><![CDATA[微信Mac客户端如何做到消息防撤回和多开？ 教程 ** 1、安装微信 Mac 官方客户端。这个是必须的，我就不解释了，哈哈。 2、打开终端（Terminal）下载源码： 3、在终端输入：git clone https://github.com/Sunnyyoung/WeChatTweak-macOS.git 4、编译安装：cd WeChatTweak-macOS &amp;&amp; sudo make install 5、打开Mac微信客户端，登录微信（如果本来就已经打开了客户端，请完全退出后重新打开一遍）。 6、打开微信的偏好设置 7、设置如下（免手机认证登录和消息撤回的通知设置） 消息撤回通知：全部接收 免手机认证登陆：开启 8、客户端无限多开的两种方法： 右键dock栏中的微信图标，点击登录新的微信账号，如图： 命令行执行：open -n /Applications/WeChat.app 9、卸载插件命令：cd WeChatTweak-macOS &amp;&amp; sudo make uninstall]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sed命令]]></title>
      <url>%2F2018%2F03%2F20%2Fsed%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[sed命令1 简介 sed(stream editor ：流编辑器)是一个编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 2 命令格式12sed [options] &apos;command&apos; file(s)sed [options] -f scriptfile file(s) 3 参数12345678910111213141516171819sed [-nefr] [动作]选项与参数：-i ：直接修改读取的文件内容，而不是输出到终端。-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。-e ：直接在命令列模式上进行 sed 的动作编辑；-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)动作说明： [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表[选择进行动作的行数]举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则[10,20[动作行为]]function：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 4 sed替换标记1234567g 表示行内全面替换。p 表示打印行。w 表示把行写入一个文件。x 表示互换模板块中的文本和缓冲区中的文本。y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）\1 子串匹配标记&amp; 已匹配字符串标记 5 sed元字符集12345678910111213^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。$ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。. 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。[] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。\(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。&amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。\&lt; 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。\&gt; 匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。x\&#123;m\&#125; 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。x\&#123;m,\&#125; 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。x\&#123;m,n\&#125; 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。 6 定界符命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符： 12sed &apos;s:test:TEXT:g&apos;sed &apos;s|test|TEXT|g&apos; 7 例子由于mac系统是原生于bsd系，sed命令和gnu是不同的。 gnu: 1sed &quot;2 a\\xxx&quot; test.txt mac: 123sed &quot;2 a\ (注意此处有空格,要在下一行添加文本)xxx&quot; test.txt (如果想换行要把&quot;写到下一行) 将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除 1nl /etc/passwd | sed &apos;2,5d&apos; 管道符 | 命令1 简介 将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推 2 命令格式1(命令1 ) | (命令2 ) 3 例子找出系统中有多少个用户使用bash 12# 第一个管道将cat命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有“/bin /bash”的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数cat /etc/passwd | grep /bin/bash | wc -l 转义字符1 字符表 转义字符 意义 ASCII码值（十进制） \a 响铃(BEL) 007 \b 退格(BS) ，将当前位置移到前一列 008 \f 换页(FF)，将当前位置移到下页开头 012 \n 换行(LF) ，将当前位置移到下一行开头 010 \r 回车(CR) ，将当前位置移到本行开头 013 \t 水平制表(HT) （跳到下一个TAB位置） 009 \v 垂直制表(VT) 011 \\ 代表一个反斜线字符’’\’ 092 \’ 代表一个单引号（撇号）字符 039 \” 代表一个双引号字符 034 \? 代表一个问号 063 \0 空字符(NULL) 000 \ooo 1到3位八进制数所代表的任意字符 三位八进制 \xhh 1到2位十六进制所代表的任意字符 二位十六进制 2 HTML转义字符 字符 十进制 转义字符 “ &#34; &quot; &amp; &#38; &amp; &lt; &#60; &lt; &gt; &#62; &gt; 不断开空格(non-breaking space) &#160; &nbsp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装class-dump]]></title>
      <url>%2F2018%2F01%2F05%2F%E5%AE%89%E8%A3%85class-dump%2F</url>
      <content type="text"><![CDATA[当Mac升级了OSX 10.11后，配置class-dump的时候，会发现逆向书上推荐的class-dump存放目录/usr/bin,class-dump存放不进去，尝试过用sudo 还是不被允许。 原因是 OSX10.11的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限。 可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。（关闭方法：开机的时候按住option出现选择磁盘的界面按command + R进入RecoveryMode，选择实用工具终端，输入csrutil disable回车搞定） 查找网上的资料，目前我用的方法是改变 (class-dump)[] 的环境变量来使用。class-dump下载地址 首先打开Terminal，输入mkdir ~/bin，在当前用户根目录下创建一个bin目录。 把下载下来的 dmg 打开，复制文件里面的class-dump到创建的bin目录下。赋予其可执行权限：chmod +x ~/bin/class-dump 打开bash_profile文件配置环境变量,vim ~/.bash_profile 按下 i 键进入编辑状态，在最下方加一行 export PATH=$HOME/bin/:$PATH 按下esc键,再按shift+: 输入 wq!进行保存退出编辑 在Terminal中执行source ~/.bash_profile 测试是否改变成功:Terminal中执行class-dump 123456789101112131415161718192021ifengdeMacBook-Pro:~ ifeng$ class-dumpclass-dump 3.5 (64 bit)Usage: class-dump [options] &lt;mach-o-file&gt; where options are: -a show instance variable offsets -A show implementation addresses --arch &lt;arch&gt; choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64) -C &lt;regex&gt; only display classes matching regular expression -f &lt;str&gt; find string in method name -H generate header files in current directory, or directory specified with -o -I sort classes, categories, and protocols by inheritance (overrides -s) -o &lt;dir&gt; output directory used for -H -r recursively expand frameworks and fixed VM shared libraries -s sort classes and categories by name -S sort methods by name -t suppress header in output, for testing --list-arches list the arches in the file, then exit --sdk-ios specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk --sdk-mac specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk --sdk-root specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut) ​ 原文：class-dump最新安装方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python获取ppt中的备注]]></title>
      <url>%2F2017%2F11%2F05%2FPython%E8%8E%B7%E5%8F%96PPT%E4%B8%AD%E7%9A%84%E5%A4%87%E6%B3%A8%2F</url>
      <content type="text"><![CDATA[安装环境（window下） 安装python 添加环境变量 右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;系统变量-&gt;Path添加python的安装目录 升级pip，因为自带的pip是旧的 python -m pip install -U pip 安装pywin32（其实是pypiwin32） pip install pypiwin32 安装OLE/COM（查看comAPI的文档） 下载安装，去这个地址，下载安装 进入安装目录C:\Program Files (x86)\Resource Kit,查看API 1 Type Libraries 2 Microsoft PowerPoint 14.0 Object Library(Ver 2.a) 代码123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python2.7.14# -*- coding: utf-8 -*-# pip install pypiwin32__author__ = 'ifeng'import win32comfrom win32com.client import Dispatch, constantsimport sysdef obtainPPTNote(pptPath): if pptPath.strip() == '': print 'need a ppt \' path' return try: listForNote = [] ppt = win32com.client.Dispatch('PowerPoint.Application') ppt.Visible = 1 pptSel = ppt.Presentations.Open(pptPath) win32com.client.gencache.EnsureDispatch('PowerPoint.Application') slide_count = pptSel.Slides.Count for i in range(1, slide_count + 1): shape_count = pptSel.Slides(i).Shapes.Count notePageRange = pptSel.Slides(i) slideRange = notePageRange.NotesPage noteShape = slideRange.Shapes.Placeholders(2) notetxtFrame = noteShape.TextFrame textrangestring = notetxtFrame.TextRange text1 = textrangestring.Text listForNote.append(text1.encode('utf-8')) print text1 except: print("opened is error for ppt") finally: ppt.Quit() return listForNoteif __name__=='__main__': obtainPPTNote("C:\\Users\\admin\\Desktop\\1.pptx")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[addChildViewController等方法]]></title>
      <url>%2F2017%2F05%2F20%2FaddChildViewController%E7%AD%89%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[addChildViewController等方法在以前，一个UIViewController的View可能有很多小的子view，用addSubview增加了大量的子view。这些子view大多数不会一直处于界面上，只是在某些情况下才会出现，虽然这些view很少出现，但是我们却常常一直把它们放在内存中。另外，当收到内存警告时，我们只能自己手工把这些view从super view中去掉。所以在iOS 5.0及以后，iOS为UIViewController类添加了新的属性和方法： 12345678@property(nonatomic,readonly) NSArray *childViewControllers- (void)addChildViewController:(UIViewController *)childController- (void) removeFromParentViewController- (void)transitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion- (void)willMoveToParentViewController:(UIViewController *)parent- (void)didMoveToParentViewController:(UIViewController *)parent 一 - (void)addChildViewController:(UIViewController *)childController12//向父视图控制器容器中添加子视图控制器[父视图控制器 addChildViewController:子视图控制器]; 当要添加的子视图控制器已经包含在视图控制器容器中，那么，相当于先从父视图控制器中删除，然后重新添加到父视图控制器中 二 - (void)removeFromParentViewController 12//从父视图控制器中删除[子视图控制器 removeFromParentViewController]; 三 -(void)transitionFromViewController:(UIViewController )fromViewController toViewController:(UIViewController )toViewController duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion 123456//交换两个子视图控制器的位置（由于添加的顺序不同，所以子试图控制器在父视图控制器中存在层次关系）[ 父视图 transitionFromViewController: 当前显示的子试图控制器，将被替换为非显示状态toViewController:将要显示的子视图控制器options:动画的方式animations:动画Blockcompletion:完成后执行的Block] 四 - (void)willMoveToParentViewController:(UIViewController *)parent 12//当一个视图控制器从视图控制器容器中被添加或者被删除之前，该方法被调用[要添加的或者别删除的子视图 willMoveToParentViewController:nil] 注意：1.removeFromParentViewController 前要调用，且parent参数为nil2.addChildViewController前，不用调用，以为系统在显示前自动调用3.只需要在transitionFromViewController方法之前调用。 五- (void)didMoveToParentViewController:(UIViewController *)parent 12//当从一个视图控制容器中添加或者移除viewController后，该方法被调用。[要添加的或者别删除的子视图 didMoveToParentViewController:父视图（或者没有父视图时nil） ] 注意：1.removeFromParentViewController 后不用我们调用，因为系统删除子控制器后自动调用。2.addChildViewController后，必须调用该方法。3.只需要在transitionFromViewController方法后，调用。 例子例子1 添加子视图控制器 1234[父视图控制器 addChildViewController:子视图控制器];子视图控制器.view.frame = 任意frame（一般是父视图的frame）;[父视图控制器.view addSubview:子视图控制器.view];[子视图控制器 didMoveToParentViewController:父视图控制器]; 例子2 移除子视图控制器 123[子视图控制器 willMoveToParentViewController:nil];[子视图控制器.view removeFromSuperview];[子视图控制器 removeFromParentViewController]; 参考1.addChildViewController2.willMoveToParentViewController和didMoveToParentViewController3.Custom Container View Controller（这篇不错，可以仔细看看，可以自定义）4 .iOS5中UIViewController的新方法(唐巧大神的杰作，有例子)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx的简介]]></title>
      <url>%2F2017%2F04%2F20%2Fnginx%E7%9A%84%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[1.nginx nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server. 2.brew brew又叫Homebrew，是Mac中的一款软件包管理工具，通过brew可以很方便的在Mac中安装软件或者是卸载软件.一般Mac电脑会默认安装有brew. brew 搜索软件 brew search nginx brew 安装软件 brew install nginx brew 卸载软件 brew uninstall nginx brew 升级 sudo brew update 查看安装信息(经常用到, 比如查看安装目录等) sudo brew info nginx 查看已经安装的软件 brew list 3.brew安装nginx 安装nginx sudo brew install nginx 启动nginx服务 sudo brew services start nginx 关闭nginx服务 sudo brew services stop nginx 查看nginx版本 nginx -v 刷新nginx nginx -s reload 停止nginx nginx -s stop http://blog.csdn.net/qq_22383951/article/details/53019034 http://www.jianshu.com/p/46b083bfd5e0 http://tengine.taobao.org/book/index.html#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac下安装Python3]]></title>
      <url>%2F2017%2F04%2F20%2Fmac%E4%B8%8B%E5%AE%89%E8%A3%85Python3%2F</url>
      <content type="text"><![CDATA[前沿对于iOS开发不要随便拆卸系统自带的Python,因为有很多 library 还是使用 Python2.7。 正文 1.安装Xcode 2.安装套件管理工具 Homebrew 3.安装Python 4.设置路径（可选） 5.确认安装 6.使用 7.安装pip等 1 安装Xcode1.1 App Store 搜索Xcode 并安装1.2 安装 Xcode command line tool1.2.1 打开命令行terminal工具 1231 control + space2 输入terminal3 回车1.2.2 安装Xcode command line tool1xcode-select --install2 安装套件管理工具 Homebrew 2.1 安装 Homebrew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.2 查看是否安装成功 1brew doctor Homebrew拓展： 2.3 搜索 12#主要看具体的信息，比如目前的版本，依赖，安装后注意事项等brew search 查找的内容 2.4 更新 12# 这会更新 Homebrew 自己，并且使得接下来的两个操作有意义——brew update 2.5 检查过时（是否有新版本） 12# 列出所有安装的软件里可以升级的那些brew outdated 2.6 升级 1234# 升级所有可以升级的软件们brew upgrade # 升级某个brew upgrade 某个软件 2.7 清理 12# 清理不需要的版本极其安装包缓存brew cleanup 3 安装Python 1brew install python 4 设置路径（可选） 如果不设置路径，则使用python的话，会默认用系统的。(这个没有具体执行，所以这个需要自己尝试) 12## 修改/etc/paths，把/usr/local/bin 移到上面去sudo vim /etc/paths 拓展：查看当前path是什么。PATH 的用途：告诉系統，我们的brew在哪里。会从上往下查找。 1echo $PAHTH 5 确认安装 1234// 系统自带的python2.7，目录为/usr/bin/pythonwhich python//brew安装的python3.4,目录为/usr/local/bin/python3which python3 6 使用未执行操作4的情况（推荐）1234// 系统自带的python a.py//brew安装的python3 a.py 执行操作4的情况 1234// 系统自带的/usr/bin/python a.py//brew安装的python a.py 7 安装pip 安装Python2.7以上版本，会自动带pip。 系统自带的python没有pip，只有easy_install 12// 给系统的python安装pipeasy_install pip 使用pip 1234// 系统自带的pip --version//brew安装的pip3 --version 参考1. MAC OSX 正確地同時安裝 PYTHON 2.7 和 PYTHON32. Mac安装python2.x与python3.x3. mac下安装python小坑]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创建.a文件]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%88%9B%E5%BB%BA-a%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[一 创建.a 创建真机.a Valid Architectures设置：armv7｜armv7s｜arm64｜i386｜x86_64 Architectures设置: armv7｜arm64 Build Active Architecture Only ：NO 用真机运行或者选择Generic iOS Device （此时） 创建模拟器.a Valid Architectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64 Architectures设置: i386｜x86_64 Build Active Architecture Only ：NO 合成支持模拟器的和真机的 lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a 注意： 如果Valid Architectures中添加了armv7s，就一定得添加armv7 二 查看.a文件包含的文件取出armv7平台的包： lipo 查看的.a -thin armv7 -output armv7/抽出的.a 查看库中所包含的文件列表： ar -t armv7/抽出的.a 三 查看 .o 的反编译代码在 Mac 上可以用 Mac 的反编译工具的otool 这个命令来反编译 .o 文件，比如 otool -tv xx.o 四 cpu 架构 i386：支持iphone模拟器， armv6：应用在iphone 3gs上 armv7：应用在iphone4 armv7s：应用在iphone4s以及iphone5 arm64：应用在最新的iphone5s上 1 xcode6不再构建arm7s 2.iOS开发——制作同时支持armv7，armv7s，arm64，i386，x86_64 3.iOS Device Compatibility Reference 4.App Distribution Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[注册 URL Scheme以及打开其他App]]></title>
      <url>%2F2017%2F04%2F05%2F%E6%B3%A8%E5%86%8CURL-Scheme%E6%AD%A5%E9%AA%A4%E4%BB%A5%E5%8F%8A%E6%89%93%E5%BC%80%E5%85%B6%E4%BB%96App%2F</url>
      <content type="text"><![CDATA[一 注册 URL Scheme1.设置URL Scheme 在safari地址栏中输入：URL Schemes：//identifier （例如：iOSEnterURL://com.Demo.www）就可以打开注册了URL Schemes的APP的。 其中URL Schemes是必填的，identifier是选填 一般情况下，是会调用先安装的app。但是iOS的系统app的URL Scheme肯定是最高的。所以我们定义URL Scheme的时候，尽量避开系统app已经定义过的URL Scheme 2. 在appdelegate中编写代码123456789101112131415#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 90000-(BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options&#123;//打开链接会走这个方法return YES;&#125;#else- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation&#123;//打开链接会走这个方法return YES;&#125;#endif 二 打开其他应用2.1 应用需要在“Info.plist”中将要使用的URL Schemes列为白名单，才可正常检查其他应用是否安装。否则报错： This app is not allowed to query for scheme… 2.2 相关API12345// iOS10 以及以后- (void)openURL:(NSURL*)url options:(NSDictionary *)optionscompletionHandler:(void (^ __nullable)(BOOL success))completion;// iOS10 以前- (void)openURL:(NSURL*)url; url：打开APP的URL options：可选字典参数。参数可以为空，也可以下边的参数 空字典：可以达到openURL:一样的行为 @{} UIApplicationOpenURLOptionUniversalLinksOnly:如果这个要打开的URL有效，并且在应用中配置它布尔值为true（YES）时才可以打开，否则打不开。 例如：@{UIApplicationOpenURLOptionUniversalLinksOnly : @YES} completion：执行成功后completionhandler在主队列中回调。如果你并不关心它的返回状态也可以传空。 相关代码1234567891011121314151617181920212223//[self openScheme:@"iOSEnterURL://"];- (void)openScheme:(NSString *)scheme &#123; UIApplication *application = [UIApplication sharedApplication]; NSURL *URL = [NSURL URLWithString:scheme]; //iOS 10 以后 if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) &#123; //1 如果这个要打开的URL有效，并且在应用中配置它布尔值为true（YES）时才可以打开，否则打不开 NSDictionary *options = @&#123;UIApplicationOpenURLOptionUniversalLinksOnly : @YES&#125;; //2 此时与openURL功能相似 // NSDictionary *options =@&#123;&#125; [application openURL:URL options:options completionHandler:^(BOOL success) &#123; NSLog(@"Open %@: %d",scheme,success); &#125;]; &#125; else &#123; if ([application canOpenURL:URL]) &#123; BOOL success = [application openURL:URL]; NSLog(@"Open %@: %d",scheme,success); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux命令行编辑快捷键]]></title>
      <url>%2F2017%2F04%2F05%2FLinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[Linux命令行编辑快捷键123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189history 显示命令历史列表↑(Ctrl+p) 显示上一条命令↓(Ctrl+n) 显示下一条命令!num 执行命令历史列表的第num条命令!! 执行上一条命令!?string? 执行含有string字符串的最新命令Ctrl+r 然后输入若干字符，开始向上搜索包含该字符的命令，继续按Ctrl+r，搜索上一条匹配的命令Ctrl+s 与Ctrl+r类似,只是正向检索Alt+&lt; 历史列表第一项Alt+&gt; 历史列表最后一项Ctrl+f 光标向前移动一个字符,相当与-&gt;Ctrl+b 光标向后移动一个字符,相当与&lt;-Alt+f 光标向前移动一个单词Alt+b 光标向后移动一个单词ls !$ 执行命令ls，并以上一条命令的参数为其参数Ctrl+a 移动到当前行的开头Ctrl+e 移动到当前行的结尾Esc+b 移动到当前单词的开头Esc+f 移动到当前单词的结尾Ctrl+l 清屏Ctrl+u 剪切命令行中光标所在处之前的所有字符（不包括自身）Ctrl+k 剪切命令行中光标所在处之后的所有字符（包括自身）Ctrl+d 删除光标所在处字符Ctrl+h 删除光标所在处前一个字符Ctrl+y 粘贴刚才所删除的字符Ctrl+w 剪切光标所在处之前的一个词（以空格、标点等为分隔符）Alt+d 剪切光标之后的词Esc+w 删除光标所在处之前的字符至其单词尾（以空格、标点等为分隔符）Ctrl+t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符Alt+t 交换当前与以前单词的位置Alt+u 把当前词转化为大写Alt+l 把当前词转化为小写Alt+c 把当前词汇变成首字符大写Ctrl+v 插入特殊字符,如Ctrl+v+Tab加入Tab字符键Esc+t 颠倒光标所在处及其相邻单词的位置Ctrl+c 删除整行Ctrl+(x u) 按住Ctrl的同时再先后按x和u，撤销刚才的操作Ctrl+s 挂起当前shellCtrl+q 重新启用挂起的shell[Ctrl] + [Alt] + [Backspace] = 杀死你当前的 X 会话。杀死图形化桌面会话，把你返回到登录屏幕。如果正常退出步骤不起作用，你可以使用这种方法。[Ctrl] + [Alt] + [Delete] = 关机和重新引导 Red Hat Linux。关闭你当前的会话然后重新引导 OS。只有在正常关机步骤不起作用时才使用这种方法。[Ctrl] + [Alt] + [Fn] = 切换屏幕。 [Ctrl] + [Alt] + 功能键之一会显示一个新屏幕。根据默认设置，从 [F1] 到 [F6] 是 shell 提示屏幕， [F7] 是图形化屏幕。[Alt] + [Tab] = 在图形化桌面环境中切换任务。如果你同时打开了不止一个应用程序，你可以使用 [Alt] + [Tab] 来在打开的任务和应用程序间切换。[Ctrl] + [a] = 把光标移到行首。它在多数文本编辑器和 Mozilla 的 URL 字段内可以使用。[Ctrl] + [d] = 从 shell 提示中注销（并关闭）。使用该快捷键，你就不必键入 exit 或 logout 。[Ctrl] + [e] = 把光标移到行尾。它在多数文本编辑器和 Mozilla 的 URL 字段内都可使用。[Ctrl] + [l] = 清除终端。该快捷操作与在命令行键入 clear 作用相同。[Ctrl] + = 清除当前行。如果你在终端下工作，使用这一快捷操作可以清除从光标处到行首的字符。[鼠标中间键] = 粘贴突出显示的文本。使用鼠标左键来突出显示文本。把光标指向你想粘贴文本的地方。点击鼠标中间键来粘贴它。在两键鼠标系统中，如果你把鼠标配置成模拟第三键，你可以同时点击鼠标的左右两键来执行粘贴。[Tab] =命令行自动补全。使用 shell 提示时可使用这一命令。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配你键入字符的所有命令。[向上] 和 [向下] 箭头 = 显示命令历史。当你使用 shell 提示时，按 [向上] 或 [向下] 箭头来前后查看你在当前目录下键入的命令历史。当你看到你想使用的命令时，按 [Enter] 键。clear = 清除 shell 提示屏幕。在命令行下键入它会清除所有这个 shell 提示屏幕中显示的数据。exit = 注销。在 shell 提示中键入它会注销当前的用户或根用户帐号。history = 显示命令历史。在 shell 提示中键入它来显示你所键入的被编号的前 1000 个命令。要显示较短的命令历史，键入 history f之后，空一格，在键入一个数字。例如： history 20 。reset = 刷新 shell 提示屏幕。如果字符不清晰或乱码的话，在 shell 提示下键入这个命令会刷新屏幕。# Ctrl-U: 擦除一行光标前面的部分。# Ctrl-H: 擦除光标前面的一个字符。# Ctrl-D: 终止输入。(退出 shell，如果您正在使用 shell 的话)。# Ctrl-C: 终止当前正在运行的程序。# Ctrl-Z: 暂停程序。&amp;&apos;&apos;)# Ctrl-S: 停止向屏幕输出。# Ctrl-Q: 重新激活向屏幕输出。默认的 shell，`bash’， 有历史编辑和 tab 补齐功能。# up-arrow: 开始历史命令搜索。# Ctrl-R: 开始增量历史命令搜索，可以按照关键字查查自己用过哪些命令。# TAB: 完整的把文件名输入到命令行。# Ctrl-V TAB: 输入 TAB 而不是扩展命令行。# Ctrl + P - 上一条命令# Ctrl + N - 下一条命令# Ctrl-U: 擦除一行光标前面的部分。# Ctrl + Y - 粘贴前一Ctrl+U类命令删除的字符 ，是粘贴不是撤销啊！下面的应用可能稍稍高级一点点# !! - 上一条命令# !-n - 倒数第N条历史命令# !-n:p - 打印上一条命令（不执行）# !?string？- 最新一条含有“string”的命令# !-n:gs/str1/str2/ - 将倒数第N条命令的str1替换为str2，并执行（若不加g,则仅替换第一个）其他一些有用的Linux命令行按键组合。Ctrl-Alt-Del:挂起或者重新启动系统，这三个Linux命令行按键在Linux下可以轻松地修改成关机的操作，这对于单用户的朋友还是很方便的# Ctrl + l - 清屏# Ctrl + A - 光标移到行首# Ctrl + E - 光标移到行尾# Ctrl + W - 清除光标之前一个单词# Ctrl + K - 清除光标到行尾的字符# Ctrl + T - 交换光标前两个字符# Ctrl + V - 输入控制字符 如Ctrl+v ,会输入^M# Ctrl + F - 光标后移一个字符# Ctrl + B - 光标前移一个字符# Ctrl + H - 删除光标前一个字符# N++F - 光标后移N个单词，N为1时可省略# N++B - 光标前移N个单词，N为1时可省略# Left-click-and-drag mouse: 选择并且拷贝到剪贴板。# Click middle mouse button: 使用剪贴板的内容粘贴。# Meta-key (Emacs terminology) 传统的是使用 Left-Alt-key]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ 中 const 使用]]></title>
      <url>%2F2017%2F04%2F05%2FC-%E4%B8%AD-const-%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一 解释如果你一看见C++中const就脱口而出：“常量！”那只能说明你对c++不甚了解。或者说你太2了.const得一些使用方法与场景如下： 1.const修饰普通变量，全局变量，静态变量 121 const int iTmp = 1;2 int const iTmpEx = 2; 变量保持其原有属性，只是多了一个const,只读属性。这里，const到底是紧贴变量名还是类型说明符号(int)都无关紧要。在修饰指针时候的不同在后面会详细说明. 2.const修饰指针const 修饰指针有三种情况：只要看const离哪个近些，const离pName最近，说明它是在修饰指针变量pName,表示pName不能改变，即不能做pName++这种修改pTmp指针的操作。123456789101112131415161718192021//A: 指针指向内容不能修改，指针本身可以修改。char chBuffer[] = "test";//等同char const* pName = chBuffer;const char *pName = chBuffer;pName++; //合法，指针本身可以修改*pName = 'c';// 非法，指针指向的内容不能被修改cout&lt;&lt;pName&lt;&lt;endl();//B: 指针指向内容能修改，指针本身不可以修改。char chBuffer[] = "test";char * const pName = chBuffer;pName++; //非法，指针本身不能被修改*pName = 'c'; //内容可以被修改cout&lt;&lt;pName&lt;&lt;endl();//C: 指针指向内容不能修改，指针本身不可以修改。char chBuffer[] = "test";const char * const pName = chBuffer;pName++; //非法，指针本身不能被修改*pName = 'c'; //非法 内容不可以被修改cout&lt;&lt;pName&lt;&lt;endl(); 3.const修饰函数参数 12345void Test(const int iAge)//函数体中，确保iAge不被修改。void Test(const char *pName)//函数体中，确保pName指向的内容不被修改。void Test(char* const pName)//函数体中，确保pName不被修改。void Test(const char* const pName)//函数体中，确保pName和pName指向的内容不被修改。void Test(const ClassTest &amp;obj);// 这种情况使用非常多，这样可以避免调用ClassTest的构造函数，直接传递类对象的地址 c++中&amp;和怎么用&amp;引用访问一个变量是直接访问，而指针是间接访问。引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。引用在开始的时候就绑定到了一个内存空间(开始必须赋初值),所以他只能是这个内存空间的名字,而不能改成其他的,当然可以改变这个内存空间的值.“&amp;”是取地址运算符“*”的用法有两种情况：（1）定义指针变量（2）间接访问运算符 123int a,*p;p=&amp;a;a=*p; 例如： 123int i = 3,j = 4;int &amp;x = i;//成为i的别名x = j;//不能否认x仍然引用i,并没有成为j的别名,只是修改了x和j共享的内存空间的值.这点与指针不同,指针在任何时刻都可以改变自己的指向 4.const修饰函数返回值const 修饰返回值的用法比较少见，有种用法，比如1const char* Test(); 那么接受它返回内容的变量也要写成const char * 类型5:const修饰类成员变量修饰类成员变量时候，初始化需要放到类初始化列表种进行初始化12345678class CTest&#123;public:int m_iAge;&#125;CTest::CTest:m_iAge(99)&#123;&#125; 6.const修饰成员函数对变量的只读访问,只是类普通变量，排除全局，静态变量。123456789101112class CTest&#123;public:void Show()const;private:int m_iAge;&#125;void CTest:: Show()const&#123;cout&lt;&lt;m_iAge;// m_iAge++; 不能修改&#125; 原文：1.C++ 中 const 使用 二 const与宏的区别 编译时刻宏是预编译（编译之前处理），const是编译阶段 编译检查.宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。 优点.宏能定义一些函数，方法。 const不能。 缺点.用大量宏，容易造成编译时间久，每次都需要重新替换 三 static 作用 修饰局部变量 延长局部变量的生命周期,程序结束才会销毁。 某个局部变量（例如static int age = 0）只会生成一份内存,只会初始化一次，所有函数，共享这个局部变量（age）。 改变局部变量的作用域，在其他函数中共享这个局部变量。static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面。 修饰全局变量 只能在本文件中访问,修改全局变量的作用域,生命周期不改变。 避免重复定义全局变量 四 extern作用: 只是用来获取全局变量(包括全局静态变量)的值(例如：extern int externFile))，不能用于定义变量(例如：extern const int a = 20）。 先在当前文件查找有没有全局静态变量(static int a，因为文件中不能有int a形式的变量)，没有找到，才会去其他文件查找全局变量（int a，其他文件里不包括静态变量，因为静态变量只能在本文件使用）。##五 static与const联合使用 声明一个静态的全局只读常量,其他文件无法访问,避免重复定义全局变量. 1static const int a = 20; 开发使用场景:在一个文件中经常使用的字符串常量，可以使用static与const组合. 12// GlobeConst.m中static const int a = 20; 六 extern与const联合使用 声明一个全局只读常量 1extern const int b = 1; 开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合.只在头文件中做声明,不做定义。 1234//GlobeConst.h中extern const int b;//GlobeConst.m中const int b ＝ 1; 六 定义与声明的区别声明不等于定义 1234//定义，指出变量名字同时为变量分配存储空间，定义包含了声明int a = 20;//声明，声明只是指出了变量的名字，并没有为其分配存储空间int a; 相关代码： 12345678910111213141516//// externFile.h// constStudy//// Created by ifeng on 16/1/15.// Copyright © 2016年 beijing. All rights reserved.//#ifndef externFile_h#define externFile_h#include &lt;stdio.h&gt;extern int externFile;extern int externFileNoStatic;#endif /* externFile_h */ 1234567891011//// externFile.c// constStudy//// Created by ifeng on 16/1/15.// Copyright © 2016年 beijing. All rights reserved.//#include "externFile.h"int externFile = 10;int externFileNoStatic = 12; 1234567891011121314151617181920212223242526272829303132333435// 全局变量：只有一份内存，所有文件共享，与extern联合使用。int a = 20;// static修饰全局变量static int age = 20;static int externFile = 11;//引用外部变量extern int externFile;//引用的是本文件的externFileextern int externFileNoStatic;//引用的是其他文件的externFile//int externFileNoStatic;不能这样声明，错误。void test()&#123;// static修饰局部变量static int age = 0;age++;int a = 5;a ++;printf("static:%d,int a:%d\n",age,a);&#125;int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;// insert code here...printf("Hello, World!\n");test();//static:1,int a:6test();//static:2,int a:6printf("static2：%d,int a :%d\n",age,a);//static2：20,int a :20extern int age;printf("extern in file：%d\n",age);//extern in file：20printf("externFile in file：%d\n",externFile);//externFile in file：11printf("externFileNoStatic out file：%d\n",externFileNoStatic);//externFile out file：12&#125;return 0;&#125; 1.C/C++中extern关键字详解2全局变量和extern详解3.【如何正确使用const,static,extern】|那些人追的干货]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程基本知识]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[一 基本概念同步和异步 同步：任务的执行过程是顺序的，在当前线程中执行任务，不具备开启新线程的能力 异步：任务的执行过程不是线性的，在新的线程中执行任务，具备开启新线程的能力 异步和同步是从任务被执行的顺序上来区分的，从这个基本概念出发，异步并不见得比同步性能高，也就是说异步模型不见得会比同步模型有优势。 然而异步和同步这个概念却非常容易和阻塞与非阻塞混淆，因为任何一个任务理论上都不可能瞬间完成，而现实中的任务通常都需要与其他系统交互，因此可能被阻塞是不可避免的 异步通常给人一个错觉，就是他比同步快。这里其实是有一个误区，因为一个任务实际被处理的时间并没有太大变化，只有在带阻塞的任务中，异步才可能比同步快，因为异步快在将同步模式下带阻塞任务执行过程中cpu的等待时间利用起来处理其他任务，借此提升了多任务系统的整体并发能力，可见，一个任务的异步不一定比同步快，同时，对于处理不阻塞的任务，异步模型也不会比同步模型快 并发、并行、串行 串行：一个任务执行完毕后，再执行下一个任务 并行：多个任务同时执行，在宏观和微观上都应该具有多个任务同时被处理的含义，这个意义上多个任务被并行处理的，单cpu永远不可能并行。 并发：宏观上多个任务在同一个时间间隔内被处理，但微观上任一时刻只有一个程序运行，可能仅仅是一个cpu分时间片去完成了多个任务 并行一定是并发，并发却不一定是并行 线程同步：多条线程按顺序执行 阻塞和非阻塞 阻塞（blocking）:任务的执行会使cpu进入等待状态 A会阻塞B的意思：需要等待A事件完成后才能完成B事件，通俗来讲就是强制等待的意思 非阻塞：任务的执行不会主动让cpu进行等待 阻塞不阻塞的原始语义实际上是看任务在宏观执行过程中对cpu的主动占用情况是否连续来区分的 在不考虑cpu时间片耗尽被重新调度或者其他干扰导致被抢占的情况下，非阻塞的任务在获得cpu后将一直执行到完成 阻塞或非阻塞的任务 隐含一个前提就是必须是任务执行从开始到结束的整个过程，关心任务是否完整完成 阻塞或非阻塞的接口： 关心当前这一步操作是否会阻塞。 死锁（deadlock）:表示由于某些互相阻塞，也就是互相的强制等待，形成了闭环，导致大家永远互相阻塞下去了，Always and Forever，也就是死锁。 开发中的现状 大部分业务都可能阻塞(网络IO，文件IO)，常见的网络收发，数据库操作等，因此在追求海量高性能的server开发中很较少用到同步模型，这也是为什么我们潜意识里会觉得同步模型慢且容易与阻塞纠缠不清的原因 — 计算机世界的任务模型原本大多是阻塞任务。 开发中大多是将带阻塞的任务分解成多个不阻塞的部分（这就是异步模型中所谓的分割点），只有在这样的前提下配合异步模型才能大幅提升系统的并发能力，这就是为什么在高性能server开发中异步与非阻塞通常被混为一谈的原因 — 计算机处理海量任务只有这样才能整体最快。 对server业务，肯定提倡使用异步模型。但异步模型对开发者并不友好，因为人类的思维习惯是线性分析事务，这就是为什么大部分开发者愿意使用同步模型的原因 — 人类看待事物的习惯本就带有顺序性 一、进程和线程1.什么是进程进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 比如:打开QQ、Xcode，系统就会分别启动2个进程 2.什么是线程线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行,1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）。 比如:使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行. 3.线程是串行1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务 比如：在1个线程中下载3个文件（分别是文件A、文件B、文件C） 二、多线程1.什么是多线程1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务，多线程技术可以提高程序的执行效率。 比如：同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C） 2.多线程的原理同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 #####思考：如果线程非常非常多，会发生什么情况？ CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）。 3.多线程的优缺点多线程的优点： 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 多线程的缺点： 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB）。如果开启大量的线程，会占用大量的内存空间，降低程序的性能，线程越多，CPU在调度线程上的开销就越大，程序设计更加复杂：比如线程之间的通信、多线程的数据共享 4.多线程在iOS开发中的应用主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。 主线程的主要作用：1.显示\刷新UI界面 2.处理UI事件（比如点击事件、滚动事件、拖拽事件等） 注意:别将比较耗时的操作放到主线程中。耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验。 三 iOS开发多线程篇—线程安全一、多线程的安全隐患资源共享，1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源。 比如：多个线程访问同一个对象、同一个变量、同一个文件。当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题 二、安全隐患分析1 产生问题： 2 解决问题： 三、如何解决1.使用互斥锁互斥锁的使用前提：多条线程抢夺同一块资源 。 互斥锁，就是使用了线程同步技术。 线程同步既是多条线程按顺序地执行任务。 123456@synchronized(锁对象) &#123; // 需要锁定的代码 &#125;例如：//只能一把锁@synchronized(self) &#123; NSLog(@&quot;示例代码&quot;); &#125; 注意：锁定1份代码只用1把锁，用多把锁是无效的 2 互斥锁的优缺点 优点：能有效防止因多线程抢夺资源造成的数据安全问题 缺点：需要消耗大量的CPU资源 3 死锁产生的四个条件 互斥条件：一个资源每次只能被一个进程使用 请求和保持请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待的资源关系 四：原子和非原子属性OC在定义属性时有nonatomic和atomic两种选择 atomic：原子属性，为setter方法加锁（默认就是atomic）。线程安全，需要消耗大量的资源 nonatomic：非原子属性，不会为setter方法加锁。非线程安全，适合内存小的移动设备。 12345678910//atomic加锁原理@property (assign, atomic) int age;- (void)setAge:(int)age&#123; @synchronized(self) &#123; _age = age; &#125;&#125; 五 iOS开发的建议 所有属性都声明为nonatomic 尽量避免多线程抢夺同一块资源 尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 四 iOS开发多线程篇—线程间通信 1 创建线程(1)手动创建线程，可以进行详细设置12345678910111213NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;可以是run的参数，也可以为nil&quot;]; [thread setName:@&quot;线程名字&quot;]; //线程的调度优先级：调度优先级的取值范围是0.0 ~ 1.0，默认0.5，值越大，优先级越高 [thread setThreadPriority:0.5]; //是否是主线程 [thread isMainThread]; //手动开始 [thread start]; //获得主线程 NSThread *mainThread = [NSThread mainThread]; //获取当前线程 NSThread *currentThread = [NSThread currentThread]; [self performSelectorInBackground:@selector(run:) withObject:@&quot;1&quot;]; (2)创建线程后自动启动线程1[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil]; (3)隐式创建并启动线程 1[self performSelectorInBackground:@selector(run) withObject:nil]; 上述2种创建线程方式的优缺点优点：简单快捷缺点：无法对线程进行更详细的设置 2 线程通信1 一个线程传递数据给另一个线程 2 在一个线程中执行完特定任务后，转到另一个线程继续执行任务 2.1 NSObject中的一些方法： 在应用程序主线程中做事情： performSelectorOnMainThread:withObject:waitUntilDone: performSelectorOnMainThread:withObject:waitUntilDone:modes: 在指定线程中做事情： performSelector:onThread:withObject:waitUntilDone: performSelector:onThread:withObject:waitUntilDone:modes: waitUntilDone参数是个bool值，如果设置为NO,相当于异步执行，当前函数执行完，立即执行后面的语句。如果设置为YES,相当于同步执行，当前线程要等待Selector中的函数执行完后再执行。 在当前线程中做事情： performSelector:withObject:afterDelay: performSelector:withObject:afterDelay:inModes: 取消发送给当前线程的某个消息 cancelPreviousPerformRequestsWithTarget: cancelPreviousPerformRequestsWithTarget:selector:object: 2 .2 GCD一个线程传递数据给另一个线程 12345678910111213141516dispatch_queue_t concurrentQueue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(concurrentQueue2, ^&#123; __block UIImage *image2 = nil; NSLog(@&quot;2&quot;); NSLog(@&quot;%@&quot;,[NSThread currentThread]); dispatch_sync(concurrentQueue2, ^&#123; /* Download the image here */ NSLog(@&quot;3&quot;); NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;); dispatch_sync(dispatch_get_main_queue(), ^&#123; /* Show the image to the user here on the main queue*/ NSLog(@&quot;4&quot;); NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;); &#125;); 五 GCDiOS进程间通信之CFMessagePort原文：1.iOS开发多线程篇—多线程简单介绍]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C 反射机制]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[1 获取Class对象Class对象其实本质上就是一个结构体，任何类的定义都是对象，这个结构体中的成员变量还是自己，这种设计方式非常像链表的数据结构。 123456789101112//obj为Object实例对象typedef struct objc_class *Class;struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; &#125;//obj为Class类对象typedef struct objc_class *Class; struct objc_class &#123; Class isa; Class super_class; /* followed by runtime specific details... */ &#125;; Object-C的类型结构 Object（实例） Class（类） Metaclass（元类） Rootclass(根类) Rootclass‘s metaclass(根元类)，且这些都是对象 object_getClass(obj)与[obj class]的区别 object_getClass(obj)返回的是obj中的isa指针； 而[obj class]则分两种情况： 当obj为实例对象时，[obj class]中class是实例方法：- (Class)class，返回的obj对象中的isa指针； 当obj为类对象（包括元类和根类以及根元类）时，调用的是类方法：+ (Class)class，返回的结果为其本身作者 Object-C的对象模型图 2 获得Class对象的三个方法。 1 可以直接用一个实例对象或类对象，直接调用Class方法获取Class对象。 2 获取到的类对象是同一个类对象（类对象的isa指针），内存地址也是一样的。 在实例方法中通过self调用class实例方法获取类对象 -(Class)instanceMethod {return [self class];} 通过类直接调用class类方法获取类对象 [UIViewController class] 在类方法中使用类对象调用class方法获取类对象 +(Class)classMethod {return [self class];} ​ 3 反射方法系统Foundation框架为我们提供了一些方法反射的API，我们可以通过这些API执行将字符串转为SEL等操作。由于OC语言的动态性，这些操作都是发生在运行时的 SEL和字符串转换 12FOUNDATION_EXPORT NSString *NSStringFromSelector(SEL aSelector);FOUNDATION_EXPORT SEL NSSelectorFromString(NSString *aSelectorName); ​ Class和字符串转换 12FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass);FOUNDATION_EXPORT Class __nullable NSClassFromString(NSString *aClassName); ​ Protocol和字符串转换 12FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *proto) ;FOUNDATION_EXPORT Protocol * __nullable NSProtocolFromString(NSString *namestr) ; ​ 4 反射方法应用 在运行时选择创建那个实例 动态选择调用哪个方法 可以由服务器传回来的参数来控制，我们可以将服务器传回来的类名和方法名，实例为我们的对象 12345678910111213141516171819202122232425262728293031323334// 1 假设从服务器获取JSON串，通过这个JSON串获取需要创建的类为ViewController，并且调用这个类的getDataList方法。#define SuppressPerformSelectorLeakWarning(Stuff) \ do &#123; \ _Pragma(&quot;clang diagnostic push&quot;) \ _Pragma(&quot;clang diagnostic ignored \&quot;-Warc-performSelector-leaks\&quot;&quot;) \ Stuff; \ _Pragma(&quot;clang diagnostic pop&quot;) \ &#125; while (0)SuppressPerformSelectorLeakWarning( Class class = NSClassFromString(@&quot;ViewController&quot;); ViewController *vc = [[class alloc] init]; SEL selector = NSSelectorFromString(@&quot;getDataList&quot;); [vc performSelector:selector];);//2 如果出现：performSelector may cause a leak because its selector is unknown//则用下边这个方法//不带参数UIViewController *_controller;SEL selector = NSSelectorFromString(@&quot;someMethod&quot;);IMP imp = [_controller methodForSelector:selector];void (*func)(id, SEL) = (void *)imp;func(_controller, selector);//3 带参数SEL selector = NSSelectorFromString(@&quot;processRegion:ofView:&quot;);IMP imp = [_controller methodForSelector:selector];CGRect (*func)(id, SEL, CGRect, UIView *) = (void *)imp;CGRect result = _controller ?func(_controller, selector, someRect, someView) : CGRectZero;//4 不会出现警告 [_controller performSelector:@selector(someMethod)]; 5 常用判断方法 当前对象是否这个类或其子类的实例 -(BOOL)isKindOfClass:(Class)aClass 当前对象是否是这个类的实例 -(BOOL)isMemberOfClass:(Class)aClass 当前对象是否遵守这个协议 -(BOOL)conformsToProtocol:(Protocol *)aProtocol 当前对象是否实现这个方法 -(BOOL)respondsToSelector:(SEL)aSelector 6 例子 根据后台推送过来的数据，进行动态页面跳转，跳转到页面后根据返回到数据执行对应的操作 用反射机制动态的创建类并执行方法 假设和后台约定格式如下： 123456789@&#123; // 类名 @&quot;className&quot; : @&quot;UserListViewController&quot;, // 数据参数 @&quot;propertys&quot; : @&#123; @&quot;name&quot;: @&quot;liuxiaozhuang&quot;, @&quot;age&quot;: @3 &#125;, // 调用方法名 @&quot;method&quot; : @&quot;refreshUserInformation&quot; &#125;; 定义一个UserListViewController类，根据远程推送过来的数据，动态进行页面跳转和调用等操作 1234567891011121314151617181920212223242526272829#import &lt;UIKit/UIKit.h&gt;// 由于使用的KVC赋值，如果不想把这两个属性暴露出来，把这两个属性写在.m文件也可以@interface UserListViewController : UIViewController@property (nonatomic,strong) NSString *name;/*!&lt; 用户名 */@property (nonatomic,strong) NSNumber *age;/*!&lt; 用户年龄 *//** 使用反射机制反射为SEL后，调用的方法 */- (void)refreshUserInformation;@end// 简单封装的页面跳转方法，只是做演示，代码都是没问题的，使用时可以根据业务需求进行修改。- (void)remoteNotificationDictionary:(NSDictionary *)dict &#123; // 根据字典字段反射出我们想要的类，并初始化控制器 Class class = NSClassFromString(dict[@&quot;className&quot;]); UIViewController *vc = [[class alloc] init]; // 获取参数列表，使用枚举的方式，对控制器属性进行KVC赋值 NSDictionary *parameter = dict[@&quot;propertys&quot;]; [parameter enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 在属性赋值时，做容错处理，防止因为后台数据导致的异常 if ([vc respondsToSelector:NSSelectorFromString(key)]) &#123; [vc setValue:obj forKey:key]; &#125; &#125;]; [self.navigationController pushViewController:vc animated:YES]; // 从字典中获取方法名，并调用对应的方法 SEL selector = NSSelectorFromString(dict[@&quot;method&quot;]); IMP imp = [vc methodForSelector:selector]; void (*func)(id, SEL) = (void *)imp; func(vc, selector); &#125; 通过runtime来实现这个功能 1 performSelector may cause a leak because its selector is unknown]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIViewAutoresizing]]></title>
      <url>%2F2017%2F04%2F05%2FUIViewAutoresizing%2F</url>
      <content type="text"><![CDATA[1 UIViewAutoresizing12345678910111213141516typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; //1 不自动调整 UIViewAutoresizingNone = 0, //2 自动调整与superView左边的距离，保证与superView右边的距离不变 UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, //3 自动调整自己的宽度，保证与superView左边和右边的距离不变 UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, // 4 自动调整与superView的右边距离，保证与superView左边的距离不变 UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, // 5 自动调整与superView顶部的距离，保证与superView底部的距离不变 UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, // 6 自动调整自己的高度，保证与superView顶部和底部的距离不变 UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, // 7 自动调整与superView底部的距离，与superView顶部的距离不变 UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5&#125;; UIViewAutoresizingFlexibleLeftMargin |UIViewAutoresizingFlexibleRightMargin 自动调整与superView左边的距离，保证与左边的距离和右边的距离和原来距左边和右边的距离的比例不变。比如原来距离为20，30，调整后的距离应为68，102，即68/20=102/30。 UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleHeight 首先，下边距是不变的，但高和上边距会变，变换的计算如下，比如superview的高度，由100加高的200。自己的下边距是50，则去掉不变的下边距后,superview的变化比例是：（100-50）/(200-50) = 50/150 = 1/3。则自己的上边距和高都变为越来的3倍 UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleBottomMargin 上边距，高，下边距都和superview同比变换,比如superview的高由100变为200。则自己的上边距，高，下边距也都变为原来的2倍 上面的变换只在superview的autoresizesSubviews为YES是才会发生 autoresizesSubviews默认为YES。同时，superview的contentMode不会影响sub view的变换。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XCode链接器参数-ObjC, -all_load, -force_load]]></title>
      <url>%2F2017%2F04%2F05%2FXCode%E9%93%BE%E6%8E%A5%E5%99%A8%E5%8F%82%E6%95%B0-ObjC-all-load-force-load%2F</url>
      <content type="text"><![CDATA[XCode链接器参数-ObjC, -all_load, -force_load1填写XCode的链接器参数的原因 Unix的标准静态库实现和Objective-C的动态特性（比如：类别（category)）之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现”selector not recognized”，也就是找不到方法定义的错误 UNIX的静态库（xxx.a）其实就是一个目标文件（xxx.o）的集合。在C语言中，编译一个源文件时如果遇到在其他文件中定义的函数，则会留下一个 undefined symbol。在链接时会通过找到其他文件中的定义来确定这个symbol。在Objective-C中，由于方法调用都是在运行期确定的，因此没有针对方法的symbol，只有针对类的。 2 下面逐个介绍3个常用参数： －ObjC：链接器会把静态库中所有的类和分类都加载到可执行文件中 只包含有类别的静态库在64位的Mac系统或者iOS系统下无法使用-ObjC标志来加载文件，,需要使用-all_load 或者-force_load标志 如果您只在Xib文件中使用了某个文件，没有在代码中使用，编译器在链接时不会链接对应符号，需要在工程属性中显式设定：在Xcode的Project -&gt; Edit Active Target -&gt; Build Setting -&gt; Other Linker Flags中添加-ObjC －all_load：链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要使用这个参数！ 如果你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件 使你的目标程序大小增大，而且容易引起一些冲突 -force_load：指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载 ​ -force_load $(SRCROOT)/静态库的名称 其中 $(SRCROOT)为：/Users/用户/工程目录 ​ 3 其他Targets选项下有Other linker flags的设置，用来填写XCode的链接器参数，如：-ObjC -all_load -force_load等。 从C代码到可执行文件经历的步骤是：​ 源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件 在最后一步需要把.o文件和c语言运行库链接起来，这时候需要用到ld命令。源文件经过一系列处理以后，会生成对应的.obj文件，然后一个项目必然会有许多.obj文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。​如果要详细研究链接器做了什么，请看：http://www.dutor.net/index.php/2012/02/what-linkers-do/​​那么，Other linker flags设置的值实际上就是ld命令执行时后面所加的参数​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用代码]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[常用代码1.button抬手、松手事件1234567891011121314151617181920212223242526272829303132333435363738394041424344//方法一-(void)createButton1&#123; UIButton *tButton = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; tButton.backgroundColor = [UIColor blackColor]; [tButton setTitle:@&quot;点击&quot; forState:UIControlStateNormal]; [tButton setTitle:@&quot;松开&quot; forState:UIControlStateHighlighted]; //处理按钮点击事件 [tButton addTarget:self action:@selector(TouchDown)forControlEvents: UIControlEventTouchDown]; //处理按钮松开状态 [tButton addTarget:self action:@selector(TouchUp)forControlEvents: UIControlEventTouchUpInside | UIControlEventTouchUpOutside]; [self.view addSubview:tButton];&#125;- (void)TouchDown&#123; //这里可以处理其他点击事件 NSLog(@&quot;按钮点击了&quot;);&#125;- (void)TouchUp&#123; //这里可以处理其他松开事件 NSLog(@&quot;按钮松开了&quot;);&#125;//方法二-(void)createButton2&#123; UIButton *tButton = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; tButton.backgroundColor = [UIColor blackColor]; [tButton setTitle:@&quot;点击&quot; forState:UIControlStateNormal]; [tButton setTitle:@&quot;松开&quot; forState:UIControlStateHighlighted]; [tButton addTarget:self action:@selector(buttonAction:forEvent:) forControlEvents:UIControlEventAllTouchEvents]; [self.view addSubview:tButton];&#125; - (void)buttonAction:(id)sender forEvent:(UIEvent *)event&#123; UITouchPhase phase = event.allTouches.anyObject.phase; if (phase == UITouchPhaseBegan) &#123; NSLog(@&quot;press&quot;); &#125; else if(phase == UITouchPhaseEnded)&#123; NSLog(@&quot;release&quot;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小工具以及常用第三方库]]></title>
      <url>%2F2017%2F03%2F03%2F%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
      <content type="text"><![CDATA[1 Object-C 时间NSDate的扩展 WMPlayer视频播放器，iOS倒计时，swift框架demo，融云SDK集成Demo，介绍融云SDK即时通讯机制和集成步骤 WXNearbyRadar雷达动画搜索附近的人的演示程序 基于 CALayer 角度渐变库 AngleGradientLayer iOS自定义alertview 即时通信第三方库 基于AFNetworking3.0网络封装 以及 XMNetworking 还有其他一些封装，通用App轮播图，ObjC基于Masonry扩展的自动计算行高带缓存，日志打印支持中文，Swift基于SnapKit扩展的自动计算行高带缓存 下拉选择框 DOPDropDownMenu-Enhanced 类似美团 类似SpringBoard 图标合并删除排序功能 textField弹出datePicker的键盘 照相机 日历 , 高仿小猪短租入住时间选择器 无限循环图片轮播器 iOS 贴纸功能实现 图表 1 iOS 股票的K线图 分时图 （2）另一个iOS-Echarts 高仿新浪微博的图片浏览器，微信里集成的相册功能 提醒的小红点 标签管理，通用型遮罩层 裁剪器 渐变导航条 电子阅读器 iOS 中一款优雅的搜索控制器 App启动加载广告页面思路 使用x3图片批量生成x2、x1图片 启动页广告。 促销栏、头条栏、广播栏、广告栏 button按钮文字图片任意布局 悬浮button floating action button 2 Swift 聊天界面 Track- 一个swift的cache库，支持LRU(近期最少使用算法) Swift开源下拉刷新和加载更多组件 UIAlertController 一个弹框 FTImageViewer 图片浏览器 滑动条 3 小工具 显示隐藏文件夹]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[# Hexo3.0和Github搭建博客（二）--站点以及Next主题配置]]></title>
      <url>%2F2017%2F02%2F17%2FHexo3-0%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%AB%99%E7%82%B9%E4%BB%A5%E5%8F%8ANext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[配置文件站点配置文件：myBlog/_config.yml123456789101112131415161718language: zh-Hans #设置语言title: 我的博客 #博客标题subtitle: 梦想 #博客副标题description: 这个blog自己看的 #博客描述author: 我 #博客描述theme: next #博客主题post_asset_folder: true #引用本地图片deploy:type: git ##部署类型，其它类型自行google之repo: https://github.com/aaa/aaa.github.io ##git仓库地址search:path: search.xml #搜索功能，需要安装hexo-generator-searchdbfield: postformat: htmllimit: 10000#多说评论和分享duoshuo_shortname: abcduoshuo_share: true 主题配置文件：myBlog/themes/next/_config.yml 12# 主题风格,其他用#注释掉scheme: Pisces 注意：配置文件要符合英文标点符号使用规范:冒号后必须空格，否则会编译错误 Hexo其他设置 设置包括：标签、分类、关于、站点搜索、引用本地图片、发布 1.添加标签页面 hexo new page tags 生成index.md文件，添加type字段123456//文件路径：myBlog/source/tags/index.md---title: tagsdate: 2016-11-15 19:10:05type: "tags"--- 2.添加分类页面 hexo new page categories 生成index.md文件，添加type字段123456//文件路径：myBlog/source/categories/index.md---title: categoriesdate: 2016-11-15 19:11:13type: "categories"--- 3.设置具体文章的categories和tag1234567//文件路径：myBlog/source/_posts/Hexo3.0和Github搭建博客.md---title: Hexo3.0和Github搭建博客date: 2017-02-15 15:41:16tags: [npm, hexo, github]categories: 搭建博客--- 4.设置关于我页面 hexo new page about 生成index.md文件,修改如下：1234567891011---//文件路径： myBlog/source/about/index.mdtitle: aboutdate: 2016-11-15 19:08:50---## 关于我一只学习前端的小菜鸟，欢迎分享知识。From: jcQQ：110Email: 110 5.加入站点内容搜索功能5.1 安装hexo-generator-searchdb npm install hexo-generator-searchdb –save 5.2 添加search字段123456//站点配置：myBlog/_config.yml中search:path: search.xmlfield: postformat: htmllimit: 10000 6.加入多说评论、分享功能登陆多说： 在站点的myBlog/_config.yml中加入duoshuo_shortname字段 duoshuo_shortname:aaa 在站点的myBlog/_config.yml中加入duoshuo_share字段 duoshuo_share: ture 7.引用图片7.1 站点的myBlog/_config.yml中修改post_asset_folder post_asset_folder: true 7.2 安装插件 npm install https://github.com/CodeFalling/hexo-asset-image – save 7.3 引用图片7.3.1 利用标签引用1231 &#123;% asset_path slug %&#125;2 &#123;% asset_img slug [title] %&#125;3 &#123;% asset_link slug [title] %&#125; 7.3.2 利用makdown1![例子](例子.png) 7.博客预览和生成、部署7.1 浏览和发布1234567#浏览hexo chexo -g s或#发布hexo chexo -g d 7.2 其他1234567hexo c = hexo clean # 清空,有问题的时候，先清空再发布hexo g = hexo generate #生成hexo s = hexo server #启动本地预览hexo d = hexo deploy #远程部署hexo n "文章标题" = hexo new "文章标题" #新建一篇博文hexo s -g #等同先输入hexo g，再输入hexo shexo d -g #等同先输入hexo g，再输入hexo d 1.Hexo官方中文文档2.Next官方中文文档3.知乎上主题推荐]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo3.0和Github搭建博客]]></title>
      <url>%2F2017%2F02%2F15%2FHexo3.0%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[1 配置环境1.1 安装brew1.1.1 命令行输入： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 1.1.2 检验是否成功 1brew doctor 1.2 安装git1brew install git 1.3 安装nvm1brew install nvm 1.3.1 为了让你可以直接在shell使用nvm指令，必须创建nvm的工作目录，并且在你的 .bash_profile 加入以下两行： 12export NVM_DIR=~/.nvm. $(brew --prefix nvm)/nvm.sh 1.3.2 终端按顺序执行以下命令: 123mkdir ~/.nvmecho "export NVM_DIR=~/.nvm" &gt;&gt; .bash_profileecho ". $(brew --prefix nvm)/nvm.sh" &gt;&gt; .bash_profile 1.3.3 重新source你的 .bash_profile来让设定生效: 1. ~/.bash_profile 1.3.4 验证nvm是否正确安装 1nvm help 1.4 安装node1.4.1 安装稳定版本1nvm install stable 1.5 安装Hexo1.5.1 命令行输入1npm install -g hexo-cli 1.5.2 初始化博客文件夹 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 2 Git Pages 服务准备2.1 注册Github账号2.2 创建仓库,名字为[你的用户名].github.io 在Repository name一栏填[你的用户名].github.io，[你的用户名]是你 Github 上的用户名，请务必按照此格式填写，否则无法在 Github 上部署博客 2.3 设置git12git config --global user.email "你的邮箱"git config --global user.name "你的用户名" 2.4 生成密钥，设置密码，输入的密码不显示（也可以不设置，按三次回车，密码为空）1ssh-keygen -t rsa -C "你的邮箱" 2.5 查看生成的ssh keys中的公钥，并复制1cat ~/.ssh/id_rsa.pub 2.6 添加SSH keys 到Github1点击右上角的头像打开setting，点击SSH Keys，点击右上角的New SSH key，将公钥复制进去创建即可 3 发布博客3.1 安装发布器插件1npm install hexo-deployer-git --save 3.2 修改站点配置文件_config.yml123deploy:type: git ##部署类型，其它类型自行google之repo: &lt;repository url&gt; ##git仓库地址 3.3 本地运行123456hexo clean # 清空hexo generate 或 hexo g # 生成hexo server 或 hexo s # 本地运行或hexo clean # 清空hexo s -g # 生成、运行 3.4 发布123456hexo clean # 清空hexo generate 或 hexo g # 生成hexo deploy 或 hexo d # 发布或hexo clean # 清空hexo d -g # 生成、发布 参考：1 gdutxiaoxu–手把手教你用Hexo+Github 搭建属于自己的博客2 syd–基于Hexo和Github搭建博客3 vinnyxiong_熊远文 – Hexo之旅(二)：Hexo博客搭建(在 Mac OS 平台)4 白衣秀才 – Hexo+Github搭建个人博客)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F15%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSRunLoop]]></title>
      <url>%2F2015%2F09%2F28%2FNSRunLoop%2F</url>
      <content type="text"><![CDATA[什么是Runloop 简单点说就是一个do while的运行循环。主要的作用就是保持程序的持续运行。比如主线程的runloop从程序打开就一直在运行。一个线程对应着一个runloop。RunLoop在第一次获取时创建，在线程结束时销毁。 NSRunLoop 和 CFRunLoopRef1 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 2 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 3.RunLoop构成 一个 RunLoop 包含若干个Mode，每个Mode又包含若干个Source/Timer/Observer。 RunLoop = n * Mode Mode = n * (mode item) mode item = (Source/Timer/Observer) 注意： 1.每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 2.一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 3.1CFRunLoopSource 和 CFRunLoopSourceRefCFRunLoopSourceSource是RunLoop的数据源抽象类,类似IOS中的protocol。 RunLoop定义两个Version的Source Source0:处理App内部事件,App自己负责管理(触发),如UIEvent,CFSocket Source1:由RunLoop和内核管理,Mach port驱动 如CFMach、CFMessage CFRunLoopSourceRef CFRunLoopSourceRef是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 4 构成 Mode Name 说明 Default NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation) 默认mode，大多数用这种mode启动run loop 和配置input sources 1.子线程默认不开启 runloop，如果需要在子线程中异步执行操作，可以利用 runloop 进行线程保活。12345678+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; 2 Runloop 启动方式与方法 启动方式 启动方法 说明 Unconditionally run 无条件进入是最简单的做法，但也最不推荐。这会使线程进入死循环，从而不利于控制 runloop，结束 runloop 的唯一方式是 kill 它，它的本质就是无限调用 runMode:beforeDate: 方法 With a set time limit runUntilDate 如果我们设置了超时时间，那么 runloop 会在处理完事件或超时后结束，此时我们可以选择重新开启 runloop。这种方式要优于前一种，也是重复调用 runMode:beforeDate:，区别在于它超时后就不会再调用 In a particular mode runMode:beforeDate: 这是相对来说最优秀的方式，相比于第二种启动方式，我们可以指定 runloop 以哪种模式运行，是 runloop 的单次调用。 31楼：作者的测试方式有问题，Run方法不是不能退出，但要求是隐式的，文档中并没有说明，Run退出的条件是当前RunLoop的所有Items为空时，也就是说当前没有源需要RunLoop处理时，Run方法就会退出。你可以试一下用Run方法启动，再向你添加到RunLoop的那个端口发消息，在回调函数里面把端口源去掉就可以直接退出了。这个测试不能用perform来完成，因为这会使你的目标RunLoop额外被添加一个Source来处理事件，所以，即使你去掉端口源，RunLoop依架不会终止。关于RunLoop，建议看源码和自己做测试，文档在这一部份的勘误实在太多 iOS:.NSRunLoop再理解 我们会经常看到这样的代码： 1234567891011- (IBAction)start:(id)sender&#123; pageStillLoading = YES; [NSThread detachNewThreadSelector:@selector(loadPageInBackground:)toTarget:self withObject:nil]; [progress setHidden:NO];//等loadPageInBackground里面的操作都完成了以后才让[progress setHidden:YES] while (pageStillLoading) &#123; [NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; &#125; [progress setHidden:YES];&#125; 这段代码很神奇的，因为他会“暂停”代码运行，而且程序运行不会因为这里有一个while循环而受到影响。在[progress setHidden:NO]执行之后，整个函数想暂停了一样停在循环里面，等loadPageInBackground里面的操作都完成了以后才让[progress setHidden:YES]运行。这样做就显得简介，而且逻辑很清晰。如果你不这样做，你就需要在loadPageInBackground里面表示load完成的地方调用[progress setHidden:YES]，显得代码不紧凑而且容易出错。 1.NSRunLoop是消息机制的处理模式 NSRunLoop的作用在于有事情做的时候使的当前NSRunLoop的线程工作，没有事情做让当前NSRunLoop的线程休眠 2.NSRunLoop是循环检测 从线程start到线程end，检测inputsource(如点击，双击等操作)同步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。 3.RunLoopMode是一个集合 包括监听事件源、定时器、以及需通知的runloop observers 模式包括： default模式：几乎包括所有输入源(除NSConnection) NSDefaultRunLoopMode模式 mode模式：处理modal panels connection模式：处理NSConnection事件，属于系统内部，用户基本不用 event tracking模式：如组件拖动输入源 UITrackingRunLoopModes 不处理定时事件 common modes模式：NSRunLoopCommonModes 这是一组可配置的通用模式。将input sources与该模式关联则同时也将input sources与该组中的其它模式进行了关联。 模式的作用 每次运行一个RunLoop，你需要指定（显式或隐式）RunLoop的运行模式 当相应的模式传递给RunLoop时 只有与该模式对应的input sources才被监控并允许RunLoop对事件进行处理 只有与该模式对应的observers才会被通知 设置runloop模式 暂停当前处理的流程，转而处理其他输入源， 当date设置为NSDate distantFuture，除非处理其他输入源结束，否则永不退出处理暂停的当前处理的流程。 123456789//指定runloop模式来处理输入源，首个输入源或date结束退出-(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)date//当前A为YES时，当前runloop会一直接收处理其他输入源，当前流程不继续处理，出为A为NO，当前流程继续 while(A)&#123; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&#125; ​​ 4 perform selector​ 在当前线程的Run Loop下执行指定的 @selector 方法 ​​- 当调用 NSObject的performSelector:onThread:时，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中​- 如果当前线程没有RunLoop的话，performSelector:onThread的方法也就失效​- 线程在执行后会退出当前的RunLoop，也就是RunLoop会在一个线程结束时一同销毁​- performSelector需要注意cancel​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970- (void)viewDidLoad &#123; [super viewDidLoad]; _isNewThreadAborted = NO; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(nslogHi) object:nil]; [thread setName:@&quot;my control thread&quot;]; [thread start]; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(nslogHello:) object:nil] [self performSelector:@selector(nslogHello) onThread:thread withObject:nil waitUntilDone:NO]; NSLog(@&quot;_end&quot;);&#125; - (void)nslogHi &#123; //1 线程一直运行或者暂时阻塞一下线程，才会执行hello //向创建的RunLoop添加NSPort（Sources），让Mode不为空，RunLoop能进入循环不会退出。run启动线程，是不会退出 //方法1 [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; //方法2 while (!_isNewThreadAborted)&#123; [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]]; NSLog(@&quot;exiting runloop.........:&quot;); &#125; //方法3 让RunLoop一直尝试运行，判断Mode是否为空，不是为空就进入RunLoop循环 while (!_isNewThreadAborted) &#123; BOOL ret = [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; NSLog(@&quot;exiting runloop.........: %d&quot;, ret); &#125; //如果不加上边的代码 NSLog(@&quot;hi....&quot;); &#125;- (void)nslogHello &#123; NSLog(@&quot;hello.....&quot;); _isNewThreadAborted = YES;&#125;最会输出： 2015-09-28 14:09:15.650 PCRunLoopThread[74414:5556013] hi.... 2015-09-28 14:09:15.650 PCRunLoopThread[74414:5555961] _end 5 手动启动runloop的方式让一个子线程不进入消亡状态，等待其他线程发来消息，处理其他事件,其实就是让线程跑一个runLoop -(void)run 运行 NSRunLoop，运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制。因为无条件运行不建议使用，因为这个接口会导致Run Loop永久性的运行在NSDefaultRunLoopMode模式，即使使用CFRunLoopStop(runloopRef);也无法停止Run Loop的运行，那么这个子线程就无法停止，只能永久运行下去。 [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:10]] 运行 NSRunLoop: 参数为运时间期限，运行模式为默认的NSDefaultRunLoopMode模式，自己设置的Run Loop运行时间，超时就退出 -(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate mode： 指定runloop模式来处理输入源 limitDate: 设置为NSDate distantFuture，除非处理其他输入源结束，否则永不退出处理暂停的当前处理的流程 return: NO表示是超时或者停止运行导致返回的，YES表示是处理事件后返回的 非Timer事件触发（比如PerfromSelector事件或者其他Input Source事件），Run Loop会退出返回YES 到达limitDate后会退出返回 显式的用CFRunLoopStop停止Run Loop 6 Run Loop和线程的关系： 每条线程都有唯一的一个与之对应的RunLoop对象 一个线程可以开启多个RunLoop，只不过都是嵌套在最大的RunLoop中，其关系是保存在一个全局的 Dictionary 里 主线程的RunLoop默认是启动的，用于接收各种输入Sources 全局获取其RunLoop [NSRunLoop mainRunLoop]或者 CFRunLoopGetMain() app结束时,销毁 子线程的RunLoop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程执行一个长时间已确定的任务则不需要 只能在线程的内部获取其RunLoop [NSRunLoop currentRunLoop]或者CFRunLoopGetCurrent()，如果有就获取，没有就创建 子线程结束时，销毁 Run Loop什么情况下使用： a. 使用ports 或 input sources 和其他线程通信 // 不了解 b. 在线程中使用timers // 如果不启动run loop，timer的事件是不会响应的 c. 在Cocoa 应用中使用performSelector…方法 // 应该是performSelector…这种方法会启动一个线程并启动run loop吧 让线程执行一个周期性的任务 // 如果不启动run loop， 线程跑完就可能被系统释放了 如下是一个CFRunLoop的demo 帮助理解其使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-(void)click:(id)sender&#123; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(playerThread: ) object:nil]; //开启线程，如果是利用NSOperation，只需要加入到NSOperationQueue里面去就好了，queue自己会在合适的时机执行线程，而不需要程序员自己去控制。 [thread start];&#125;//!!!如果没有如下的currentLoop 那么不会执行initPlayer方法中的timer 即执行完playerThread便结束 - (void) playerThread:(id)unused&#123; currentLoop = CFRunLoopGetCurrent();//子线程的runloop引用 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];//为子线程创建自动释放池 [self initPlayer]; CFRunLoopRun(); [pool release];&#125;-(void) initPlayer&#123;// 在这里你可以初始化一个工作类，比如声音或者视频播放//注：timer的创建和释放必须在同一线程中。//[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 此方法会retain timer对象的引用计数。 [NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(checkState:) userInfo:nil repeats:YES]; &#125;-(void) checkState:(NSTimer*) timer&#123;//需要退出自定义的线程了 if()&#123; //释放子线程里面的资源 //释放资源的代码.... /*结束子线程任务 CFRunLoopStop,This function forces rl to stop running and return control to the function that called CFRunLoopRun or CFRunLoopRunInMode for the current run loop activation. If the run loop is nested with a callout from one activation starting another activation running, only the innermost activation is exited.*/ //CFRunLoopStop(currentLoop); &#125; for(int i = 0 ; i &lt; 100; i++) &#123; NSLog(@&quot;%d&quot;, i); &#125; //CFRunLoopStop 会将当前timer结束掉 如果runloop不结束 timer会反复执行 CFRunLoopStop(currentLoop); &#125; 3.1 例子 在timer与table同时执行情况，当拖动table时，runloop进入UITrackingRunLoopModes模式下，不会处理定时事件，此时timer不能处理，所以此时将timer加入到NSRunLoopCommonModes模式(addTimer forMode) 1234567891011//1 此方法默认添加到当前NSRunLoop中[NSTimer schduledTimerWithTimeInterval: target:selector:userInfo:repeats];//2 手动制定添加到自己新建的NSRunLoop的中。注意 timer的释放 NSTimer *timer = [NSTimer timerWithTimeInterval: invocation:repeates:]; NSTimer *timer = [[NSTimer alloc] initWithFireDate:...];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 在scroll一个页面时来松开，此时connection不会收到消息，由于scroll时runloop为UITrackingRunLoopModes模式，不接收输入源，此时要修改connection的mode 1234567NSURLRequest *request = ...NSURLConnection *connection = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO];[connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];[connection start]; 在你open stream之前，给流对象发送一个scheduleInRunLoop:forMode: 消息，来将该对象配置到一个run loop接收stream events。这样，当流中没有数据可读时可以避免delegate阻塞。如果流是发生在另一个线程，你需要确认该流对象是配置在那个线程的run loop中。你不应该尝试从一个除了包含该流对象的run loop的线程的其他线程中对流进行操作。最后，对NSInputStream对象发送open消息开始对输入数据的流操作。 1234567891011121314//你创建对象之后你应该设置其delegate。当把NSInputStream对象配置到一个run loop，并且有与流相关的事件(例如流中有可读数据)发生时，该对象会收到stream:handleEvent:消息- (void)setUpStreamForFile:(NSString *)path &#123; // iStream is NSInputStream instance variable iStream = [[NSInputStream alloc] initWithFileAtPath:path]; [iStream setDelegate:self]; [iStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [iStream open];&#125; 1234567线程实现的几种方式： Operation Objects // NSOperation及相关子类 // dispatch_async等相关函数 Idle-time notifications // NSNotificationQueue,低优先级Asynchronous functions // 异步函数Timers // NSTimer Separate processes // 没用过 线程创建的成本 kernel data structures 约1KB Stack space 512KB(secondary threads) 1MB(iOS main thread) Creation time 约90 microseconds ​​]]></content>
    </entry>

    
  
  
</search>
